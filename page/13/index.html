<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hxx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hxx">
<meta property="og:url" content="http://hxx-98.github.io/page/13/index.html">
<meta property="og:site_name" content="Hxx">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hxx-98">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hxx" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hxx</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hxx-98.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据库复习笔记二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/" class="article-date">
  <time datetime="2020-03-11T13:02:56.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/">《数据库系统概论》(王珊  萨师煊)复习笔记（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章  关系数据库"></a>第二章  关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1 关系数据结构及形式化定义"></a>1 关系数据结构及形式化定义</h2><ol>
<li><p>二维表：逻辑结构，从用户角度，关系模型中数据的逻辑结构是一张二维表</p>
</li>
<li><p>建立在集合代数的基础上</p>
</li>
<li><p>域：一组具有相同数据类型的值的集合</p>
</li>
<li><p><strong>笛卡尔积</strong>：给定一组域D1，D2，…，Dn，这些域中可以有相同的。</p>
<p>D1×D2×…×Dn ＝｛（d1，d2，…，dn）｜di属于Di，i＝1，2，…，n｝</p>
<p><strong>元组</strong>：笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组（n-tuple）或简称元组(Tuple)<br>(张三，计算机专业，男)等都是元组 ，通常用t表示<br><strong>分量</strong>：笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个分量。张三，计算机专业，男等都是分量<br><strong>基数</strong>：若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1，2，…，n），则D1×D2×…×Dn的基数M为：M = M1<em>M2</em>…..*Mn</p>
<p><strong>表示方法</strong>：笛卡尔积可表示为一个二维表，表中的每行对应一个元组，表中的每列对应一个域</p>
<p>示例：D1为教师集合（T）= {t1，t2}， D2为学生集合（S）= {s1，s2 ，s3}，D3为课程集合（C）= {c1，c2}<br>则D1×D2×D3是个三元组集合，元组个数为2×3×2，是所有可能的（教师，学生，课程）元组集合</p>
<p><strong>子集</strong></p>
</li>
</ol>
<ul>
<li>关系<br>   D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，表示为R（D1，D2，…，Dn）<br>R：关系名<br>   n：关系的目或度（Degree）<ul>
<li>元组<br>关系中的每个元素是关系中的元组，通常用t表示。</li>
<li>单元关系与二元关系<br>当n=1时，称该关系为单元关系（Unary relation）或一元关系<br>当n=2时，称该关系为二元关系（Binary relation）</li>
</ul>
</li>
<li>关系的表示<br>   关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域<ul>
<li>属性<br>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。n目关系必有n个属性</li>
</ul>
</li>
</ul>
<ol start="5">
<li><p>候选码（Candidate key）：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。简单的情况：候选码只包含一个属性</p>
</li>
<li><p>全码（All-key）：最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码</p>
</li>
<li><p>主码：若一个关系有多个候选码，则选定其中一个为主码（Primary key）</p>
</li>
<li><p>主属性：候选码的诸属性称为主属性（Prime attribute）<br>不包含在任何侯选码中的属性称为非主属性（ Non-Prime attribute）或非码属性（Non-key attribute）</p>
</li>
<li><p>三类关系<br>基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示<br>查询表：查询结果对应的表<br>视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
</li>
<li><p>关系模式：是型，是对关系的描述，是静态的、稳定的</p>
<ul>
<li>是元素集合的结构</li>
<li>元组语义以及完整性约束条件</li>
<li>属性间的数据依赖关系集合</li>
</ul>
<p>通常简记为R (U)    或    R (A1，A2，…，An)    R: 关系名      A1，A2，…，An  : 属性名</p>
</li>
<li><p>关系数据库<br>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p>
</li>
</ol>
<ul>
<li>型：关系数据库模式，包括若干域的定义；在这些域上定义的若干关系模式。</li>
<li>值：关系模式在某一时刻对应的关系的集合，简称为关系数据库</li>
</ul>
<h2 id="2-关系操作"><a href="#2-关系操作" class="headerlink" title="2 关系操作"></a>2 关系操作</h2><ol>
<li>常用的关系操作<ul>
<li>查询：选择、投影、连接、除、并、交、差</li>
<li>数据更新：插入、删除、修改，查询的表达能力是其中最主要的部分</li>
<li><strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong></li>
</ul>
</li>
<li>操作特点：<ul>
<li>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</li>
<li>高度非过程化：只要指出“做什么”，不需要描述“怎么做”</li>
</ul>
</li>
</ol>
<h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3 关系代数"></a>3 关系代数</h2><ol>
<li>关系数据库语言分类<ul>
<li><strong>关系代数语言</strong>：用对关系的运算来表达查询要求。代表：ISBL</li>
<li><strong>关系演算语言</strong>：用谓词来表达查询要求<br>元组关系演算语言：谓词变元的基本对象是元组变量。代表：APLHA, QUEL<br>域关系演算语言：谓词变元的基本对象是域变量。代表：QBE</li>
<li><strong>关系代数和关系演算是相互等价的</strong></li>
<li>具有关系代数和关系演算<strong>双重特点</strong>的语言。代表：SQL（Structured Query Language） </li>
</ul>
</li>
<li>定义：关系数据库的一种抽象的查询语言，用对关系的运算来表达查询。</li>
<li>要素：运算对象（关系）、关系运算符</li>
<li>关系代数运算符</li>
</ol>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6.PNG"></p>
<ol start="5">
<li><p>交</p>
<ul>
<li><p>R和S：具有相同的目n；相应的属性取自同一个域</p>
</li>
<li><p>R∩S：仍为n目关系，由既属于R又属于S的元组组成</p>
<p>R∩S = { t|t 属于 R ∧ t 属于S }</p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E4%BA%A4%E9%9B%86%E4%B8%BE%E4%BE%8B.PNG"></p>
</li>
<li><p>差</p>
<ul>
<li><p>R和S：具有相同的目n，相应的属性取自同一个域</p>
</li>
<li><p>R - S ：仍为n目关系，由属于R而不属于S的所有元组组成     </p>
<p>R -S = { t|t属于R ∧ t属于S }  </p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%B7%AE%E9%9B%86.PNG"></p>
</li>
</ul>
</li>
<li><p>并</p>
<ul>
<li><p>R和S:具有相同的目n（即两个关系都有n个属性），相应的属性取自同一个域</p>
</li>
<li><p>R∪S ：仍为n目关系，由属于R或属于S的元组组成   R∪S = { t|t 属于 R ∨ t 属于S }</p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%B9%B6%E9%9B%86.PNG"></p>
</li>
</ul>
</li>
<li><p>笛卡尔积</p>
<ul>
<li>严格地讲应该是广义的笛卡尔积（Extended Cartesian Product）<br>R: n目关系，k1个元组<br>S: m目关系，k2个元组</li>
<li>R×S<br>列：（n+m）列元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组<br>行：k1×k2个元组</li>
</ul>
</li>
</ol>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/笛卡尔积.PNG" style="zoom:80%;" />

<ol start="5">
<li><p>选择</p>
<ul>
<li><p>在关系R中选择满足给定条件的元组   F(R)={t | t 属于 R ^F(t) = ‘真’}</p>
<p>F是选择的条件， F(t)要么为真，要么为假。F的形式：由逻辑运算符连接关系表达式而成</p>
</li>
</ul>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/选择运算.PNG" style="zoom:80%;" />
</li>
<li><p>投影</p>
<p>从关系R中取若干列组成新的关系（从列的角度），投影的结果中要去掉相同的行</p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/投影.PNG" style="zoom:80%;" />
</li>
<li><p>连接</p>
<p>连接操作是从两个关系的广义笛卡尔积中选择属性间满足一定条件的元组。通常写为：</p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%BF%9E%E6%8E%A5%E5%AE%9A%E4%B9%89.PNG"></p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/连接.PNG" style="zoom:80%;" />
</li>
<li><p>等值连接和自然连接</p>
<p>等值连接：从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组</p>
<p>自然连接：若R和S具有相同的属性组（来自相同的域，表示相同的含义），且连接的运算符θ为“=”，在连接的结果中去掉重复的属性组</p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/等值自然连接.PNG" style="zoom:80%;" />
</li>
<li><p>外连接<br>如果把舍弃的元组也保存在结果关系中，而在其他属性上填空值(Null)，这种连接就叫做外连接。</p>
</li>
<li><p>左外连接<br>如果只把左边关系R中要舍弃的元组保留就叫做左外连接。</p>
</li>
<li><p>右外连接<br>如果只把右边关系S中要舍弃的元组保留就叫做右外连接。</p>
</li>
<li><p>象集</p>
<p>关系R(X , Z)，X、 Z是属性组，x是X上的取值，定义x在R中的象集为从R中选出在X上取值为x的元组，去掉X上的分量，只留Z上的分量    Zx = { t[Z] | t属于R 且 t[X]= x }</p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/象集.PNG" style="zoom:80%;" />
</li>
<li><p>除</p>
<ul>
<li>给定关系R（X，Y）和S（Y，Z），其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的值域。</li>
<li>R与S的除运算得到一个新的关系P（X），P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。</li>
</ul>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/除.PNG" style="zoom:80%;" />

</li>
</ol>
<h2 id="4-关系的完整性"><a href="#4-关系的完整性" class="headerlink" title="4 关系的完整性"></a>4 关系的完整性</h2><ol>
<li>实体完整性和参照完整性：关系模型必须满足的完整性约束条件，称为关系的两个不变性，应该由关系系统自动支持。</li>
<li>用户定义的完整性： 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 </li>
<li>实体完整性：若属性A是基本关系R的主属性，则属性A不能取空值</li>
<li>外码<ul>
<li>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码</li>
<li>基本关系R称为参照关系（Referencing  Relation）</li>
<li>基本关系S称为被参照关系（Referenced Relation）或目标关系（Target Relation）</li>
<li>例：学生关系的“专业号”与专业关系的主码“专业号”相对应<br>“专业号”属性是学生关系的外码<br>专业关系是被参照关系，学生关系为参照关系</li>
<li>关系R和S不一定是不同的关系</li>
<li>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li>
<li>外码并不一定要与相应的主码同名，当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别 </li>
</ul>
</li>
<li>参照完整性<ul>
<li>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元组的主码值</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/" data-id="cknhe7bxc006yows693kt3xj8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" class="article-date">
  <time datetime="2020-03-11T02:30:58.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">《数据库系统概论》(王珊  萨师煊)复习笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-数据库技术发展"><a href="#1-数据库技术发展" class="headerlink" title="1 数据库技术发展"></a>1 数据库技术发展</h2><ul>
<li>层次数据库技术：Rockwell公司与IBM公司合作研制了基于层次模型的数据管理系统IMS</li>
<li>网状数据库技术：通用电气公司的Charles Bachman主持设计与实现了网状模型的数据库管理系统IDS；CODASYL下属的数据库任务组DBTG提出的网状数据库模型以及数据定义和数据操纵语言即DDL和DML的规范说明，推出了DBTG报告；</li>
<li>关系数据库技术：IBM公司San Jose实验室的研究员Edgar F.Codd提出了关系数据模型</li>
<li>新一代数据库技术<ol>
<li>面向对象数据库</li>
<li>XML数据库</li>
<li>网络数据库、嵌入式移动数据库、多媒体数据库、知识数据库、模糊数据库……</li>
</ol>
</li>
</ul>
<h2 id="2-数据库系统概述"><a href="#2-数据库系统概述" class="headerlink" title="2 数据库系统概述"></a>2 数据库系统概述</h2><h3 id="2-1-四个基本概念"><a href="#2-1-四个基本概念" class="headerlink" title="2.1 四个基本概念"></a>2.1 四个基本概念</h3><ul>
<li><p><strong>数据(Data)</strong></p>
<ol>
<li><p>数据库中存储的基本对象，描述事物的符号记录</p>
</li>
<li><p>数据的种类</p>
<p>侠义：数字</p>
<p>广义：文字、图形、图象、声音</p>
</li>
<li><p>数据与其语义不可分</p>
<p>例如：93是一个数据，语义可以是学生某门课的成绩</p>
</li>
<li><p>记录是计算机中表示和存储数据的一种格式，是有结构的数据</p>
</li>
</ol>
</li>
<li><p><strong>数据库(DB)</strong></p>
<p>​        长期储存在计算机内，有组织的、可共享的大量数据的集合</p>
</li>
<li><p><strong>数据库管理系统(DBMS)</strong></p>
<ol>
<li><p>位于用户和操作系统之间的一层数据管理软件，是基础软件，一个大型复杂的软件系统。科学的组织和存储数据、高效的获取和维护数据。</p>
</li>
<li><p>主要功能</p>
<ul>
<li>数据定义功能</li>
</ul>
<p>​         提供数据定义语言(DDL)，及其翻译处理程序<br>​         定义数据库中的数据对象</p>
<ul>
<li><p>数据操纵功能</p>
<p>  提供数据操纵语言(DML)，及其编译程序<br>​  操纵数据实现对数据库的基本操作(查询、插入、删除和修改)</p>
</li>
<li><p>数据组织、存储和管理<br>​分类组织、存储和管理各种数据；  确定组织数据的文件结构和存取；实现数据之间的联系；提供多种存取方法提高存取效率</p>
</li>
<li><p>数据库的运行管理</p>
<p>保证数据的安全性、完整性； 多用户对数据的并发使用； 发生故障后的系统恢复</p>
</li>
<li><p>数据库的建立和维护功能(实用程序)</p>
<p> 数据库数据批量装载； 数据库转储；介质故障恢复； 数据库的重组织；性能监视等</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>数据库系统(DBS)</strong></p>
<p>在计算机系统中引入数据库后的系统构成，包括数据库、数据库管理系统、应用系统、数据库管理员</p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.PNG"></p>
<h3 id="2-2-数据管理技术的产生和发展"><a href="#2-2-数据管理技术的产生和发展" class="headerlink" title="2.2 数据管理技术的产生和发展"></a>2.2 数据管理技术的产生和发展</h3><ul>
<li><p>数据管理：对数据进行分类、组织、编码、存储、检索和维护</p>
</li>
<li><p><strong>发展</strong></p>
<ol>
<li><p>人工管理阶段：数据不保存；应用程序管理数据；数据不共享，冗余度极大；数据不具有独立性</p>
</li>
<li><p>文件系统阶段：</p>
<p>优点： 数据可长期保存；应用程序管理数据 ；文件系统管理数据<br>缺点：数据共享性差、冗余度大；数据独立性差</p>
</li>
<li><p>数据库系统阶段</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-3-数据库系统的特点"><a href="#2-3-数据库系统的特点" class="headerlink" title="2.3 数据库系统的特点"></a>2.3 数据库系统的特点</h3><ul>
<li><p>数据结构化</p>
<p>文件系统：每个文件内部是有结构的，但是记录之间没有联系</p>
<p>关系数据库：不仅数据内部结构化，整体也是结构化的，数据之间具有联系</p>
</li>
<li><p>数据的共享性高，冗余度低，易扩充</p>
</li>
<li><p>数据独立性高</p>
<ol>
<li><p>物理独立性</p>
<p>指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</p>
</li>
<li><p>逻辑独立性<br>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</p>
</li>
<li><p>数据独立性是由DBMS的二级映像功能来保证的</p>
</li>
</ol>
</li>
<li><p>数据由DBMS统一管理和控制</p>
<ol>
<li><p>数据的安全性（Security）保护<br>保护数据，以防止不合法的使用造成的数据的泄密和破坏。</p>
</li>
<li><p>数据的完整性（Integrity）检查<br>将数据控制在有效的范围内，或保证数据之间满足一定的关系。</p>
</li>
<li><p>并发（Concurrency）控制<br>对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p>
</li>
<li><p>数据库恢复（Recovery）</p>
<p>将数据库从错误状态恢复到某一已知的正确状态。</p>
</li>
</ol>
</li>
</ul>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3 数据模型"></a>3 数据模型</h2><h3 id="3-1-两大数据模型"><a href="#3-1-两大数据模型" class="headerlink" title="3.1 两大数据模型"></a>3.1 两大数据模型</h3><ul>
<li>在数据库中用数据模型这个工具来来<strong>抽象、表示和处理</strong>现实世界中的事物。通俗地讲数据模型就是现实世界的模拟。</li>
<li>数据模型应满足三方面要求：能比较真实地模拟现实世界，容易为人所理解，便于在计算机上实现</li>
<li>分类<ol>
<li>概念模型（信息模型）：它是按<strong>用户</strong>的观点来对数据和信息建模，用于数据库设计。 </li>
<li>逻辑模型和物理模型：按<strong>计算机系统</strong>的观点对数据建模，用于DBMS的实现。<ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。</li>
<li>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%AF%B9%E5%AE%A2%E8%A7%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B.PNG"></p>
<h3 id="3-2-数据模型的组成要素"><a href="#3-2-数据模型的组成要素" class="headerlink" title="3.2 数据模型的组成要素"></a>3.2 数据模型的组成要素</h3><ul>
<li><strong>数据结构</strong></li>
<li><strong>数据操作</strong></li>
<li><strong>完整性约束条件</strong></li>
</ul>
<h3 id="3-3-概念模型"><a href="#3-3-概念模型" class="headerlink" title="3.3 概念模型"></a>3.3 概念模型</h3><ul>
<li>信息世界的基本概念<ol>
<li>实体（Entity）：客观存在并可相互区别的事物称为实体，可以是具体的人、事、物或抽象的概念。</li>
<li>属性（Attribute）：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。  </li>
<li>码（Key）：唯一标识实体的属性集称为码。</li>
<li>域（Domain）：属性的取值范围称为该属性的域。 </li>
<li>实体型（Entity Type）：用<strong>实体名及其属性名集合</strong>来抽象和刻画<strong>同类实体</strong>称为实体型。例如：学生（学号、姓名、性别）</li>
<li>实体集（Entity Set）：同一类型实体的集合称为实体集</li>
<li>联系（Relationship）：现实世界中事物内部以及事物之间的联系在信息世界中反映为<strong>实体内部的联系和实体之间</strong>的联系。<ul>
<li>实体内部的联系通常是指组成实体的各属性之间的联系</li>
<li>实体之间的联系通常是指不同实体集之间的联系</li>
<li>一对一联系（1:1）、一对多联系（1:n）、多对多联系（m:n）</li>
</ul>
</li>
</ol>
</li>
<li>实体 — 联系方法（E-R方法、E-R模型）<ol>
<li>实体型：用矩形表示，矩形框内写实体名</li>
<li>属性：用椭圆表示，并用无向边将其与相应的实体连接起来</li>
<li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）</li>
<li>联系的属性：联系本身也是一种实体型，也   可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 </li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%81%94%E7%B3%BB%E5%B1%9E%E6%80%A7%E5%9B%BE.PNG"></p>
<h3 id="3-4-最常用的数据模型"><a href="#3-4-最常用的数据模型" class="headerlink" title="3.4 最常用的数据模型"></a>3.4 最常用的数据模型</h3><ul>
<li><p>层次模型：用<strong>树形结构</strong>来表示各类实体以及实体间的联系</p>
</li>
<li><p>网状模型：采用<strong>网状模型</strong>作为数据的组织方式 </p>
</li>
<li><p>关系模型：采用<strong>关系模型</strong>作为数据的组织方式</p>
<ol>
<li><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年龄</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>张三</td>
<td>16</td>
<td>男</td>
</tr>
<tr>
<td>0002</td>
<td>李四</td>
<td>18</td>
<td>男</td>
</tr>
</tbody></table>
</li>
<li><p>数据结构</p>
<ul>
<li>关系：一个关系对应通常说的一张表</li>
<li>元组（Tuple）：表中的一行即为一个元组</li>
<li>属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性</li>
<li>主码（Key）：表中的某个属性组，它可以唯一确定一个元组。</li>
</ul>
</li>
<li><p>域（Domain）：属性的取值范围。</p>
<ul>
<li>分量：元组中的一个属性值。</li>
<li>关系模式：对关系的描述，关系名（属性1，属性2，…，属性n）</li>
</ul>
</li>
<li><p><strong>关系的完整性约束条件</strong></p>
<ul>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义的完整性</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4-数据库系统结构"><a href="#4-数据库系统结构" class="headerlink" title="4 数据库系统结构"></a>4 数据库系统结构</h2><h3 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h3><ul>
<li><p>从最终用户角度：</p>
<ol>
<li><p>单用户结构</p>
<p>整个数据库系统(应用程序、DBMS、数据)装在一台计算机上，为一个用户独占，不同机器之间不能共享数据。</p>
</li>
<li><p>主从式结构</p>
<ul>
<li>一个主机带多个终端的多用户结构</li>
<li>数据库系统，包括应用程序、DBMS、数据，都集中存放在主机上，所有处理任务都由主机来完成。各个用户通过主机的终端并发地存取数据库，共享数据资源。</li>
<li>优点<br>易于管理、控制与维护。</li>
<li>缺点<br>当终端用户数目增加到一定程度后，主机的任务会过分繁重，成为瓶颈，从而使系统性能下降。<br>系统的可靠性依赖主机,当主机出现故障时，整个系统都不能使用。</li>
</ul>
</li>
<li><p>分布式结构</p>
<ul>
<li>数据库中的数据在<strong>逻辑上是一个整体，但物理地分布</strong>在计算机网络的不同结点上。</li>
<li>网络中的每个结点都可以独立处理本地数据库中的数据，执行局部应用</li>
<li>同时也可以同时存取和处理多个异地数据库中的数据，执行全局应用</li>
<li>优点<br>适应了地理上分散的公司、团体和组织对于数据库应用的需求。</li>
<li>缺点<br>数据的分布存放给数据的处理、管理与维护带来困难。<br>当用户需要经常访问远程数据时，系统效率会明显地受到网络传输的制约。</li>
</ul>
</li>
<li><p>客户／服务器</p>
<ul>
<li>把DBMS功能和应用分开<br>网络中某个（些）结点上的计算机专门用于执行DBMS功能，称为<strong>数据库服务器</strong>，简称服务器，其他结点上的计算机安装DBMS的外围应用开发工具，用户的应用系统，称为<strong>客户机</strong></li>
<li>集中的服务器结构<br>一台数据库服务器，多台客户机</li>
<li>分布的服务器结构<br>在网络中有多台数据库服务器<br>分布的服务器结构是客户／服务器与分布式数据库的结合</li>
</ul>
</li>
<li><p>浏览器／应用服务器／数据库服务器多层结构</p>
<ul>
<li><p>客户端：<br>浏览器软件、用户界面</p>
<p> 浏览器的界面统一，广大用户容易掌握</p>
<p>大大减少了培训时间与费用。</p>
</li>
<li><p>服务器端分为两部分：<br>Web服务器、应用服务器<br>数据库服务器等</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>从数据库管理系统角度，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构 </p>
</li>
</ul>
<h3 id="4-2-数据库系统的三级模式结构"><a href="#4-2-数据库系统的三级模式结构" class="headerlink" title="4.2 数据库系统的三级模式结构"></a>4.2 数据库系统的三级模式结构</h3><ul>
<li>结构图</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png"></p>
<ul>
<li>模式<ol>
<li>模式（逻辑模式）<br><strong>数据库中全体数据的逻辑结构和特征的描述</strong><br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式</li>
<li>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关</li>
<li>模式的定义<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</li>
</ol>
</li>
<li>外模式（子模式、用户模式）<ol>
<li><strong>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</strong>，数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>外模式的地位：介于模式与应用之间<ul>
<li>模式与外模式的关系：一对多<br>外模式通常是模式的子集。<br>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求。<br>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。</li>
<li>外模式与应用的关系：一对多<br>同一外模式也可以为某一用户的多个应用系统所使用<br>但一个应用程序只能使用一个外模式</li>
</ul>
</li>
<li>外模式的用途<ul>
<li>保证数据库安全性的一个有力措施</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
</li>
</ol>
</li>
<li>内模式（存储模式）<ol>
<li><strong>是数据物理结构和存储方式的描述</strong></li>
<li><strong>是数据在数据库内部的表示方式</strong></li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B.png"></p>
<h3 id="4-3-数据库二级映像功能与数据独立性"><a href="#4-3-数据库二级映像功能与数据独立性" class="headerlink" title="4.3 数据库二级映像功能与数据独立性"></a>4.3 数据库二级映像功能与数据独立性</h3><ul>
<li><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p>
<ol>
<li><p>外模式／模式映像</p>
<ul>
<li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li>
<li>当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称<strong>数据的逻辑独立性</strong>。</li>
</ul>
</li>
<li><p>模式／内模式映像 </p>
<ul>
<li><p>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的</p>
</li>
<li><p>数据库中模式／内模式映象是唯一的，该映象定义通常包含在模式描述中</p>
</li>
<li><p>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变</p>
</li>
<li><p>应用程序不受影响。保证了数据与程序的物理独立性，简称<strong>数据的物理独立性</strong>。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" data-id="cknhe7bxb006tows6c6igeu0k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-deque" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/deque/" class="article-date">
  <time datetime="2020-03-05T12:53:48.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/deque/">deque</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="deque-容器"><a href="#deque-容器" class="headerlink" title="deque 容器"></a>deque 容器</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li>功能：双端数组，可以对头端进行插入删除操作,deque的迭代器支持随机访问</li>
<li>和vector的区别<ol>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度比vector快</li>
<li>vector访问元素时的速度没有deque快</li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/deque.PNG"></p>
<ul>
<li><p>内部工作原理</p>
<ol>
<li>deque有一个中控器，维护每段缓冲区的内容，缓冲区中存放真实数据</li>
<li>中控器维护的是每个缓冲区的地址，是的使用deque时像一片连续的内存空间</li>
<li>这种结构决定了比vector插入数据时要快，然而访问数据比vector慢</li>
</ol>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/deque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.PNG"></p>
</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><ul>
<li>函数原型<ol>
<li><code>deque&lt; T &gt; deq;</code>   //默认构造函数</li>
<li><code>deque(beg,end);</code>  //构造函数将[begin,end)区间的元素拷贝给本身</li>
<li><code>deque(n,elem);</code>  //构造函数将n个elem拷贝给本身</li>
<li><code>deque(const deque &amp;deq);</code>//拷贝构造函数</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; deq)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = deq.begin(); it != deq.end(); it++) &#123;</span><br><span class="line">		<span class="comment">//*it = 100;//报错，限定为只读状态</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		deq.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	printDeque(deq);</span><br><span class="line">	<span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(deq.begin(),deq.end())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3(d1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-赋值操作"><a href="#3-赋值操作" class="headerlink" title="3.赋值操作"></a>3.赋值操作</h3><ul>
<li>函数原型<ol>
<li><code>deque&amp; operator = (const deque &amp;deq);  </code></li>
<li><code>assign(beg,end);</code>// 将[begin,end)区间的元素拷贝给本身</li>
<li><code>assign(n,elem);</code>//将n个elem拷贝给本身</li>
</ol>
</li>
</ul>
<h3 id="4-大小操作"><a href="#4-大小操作" class="headerlink" title="4. 大小操作"></a>4. 大小操作</h3><ul>
<li>函数原型<ol>
<li><code>deque.empty();</code> //判断容器是否为空</li>
<li><code>deque.size();</code>//返回容器中元素的个数</li>
<li><code>deque.resize(num);</code>//重新指定容器的长度为num,若瑢变长，则以默认值填充新位置，如果变短，则末尾超出的容器长度的元素将会被删除</li>
<li><code>deque.resize(n,elem);</code>//多出的值用elem填充</li>
</ol>
</li>
</ul>
<h3 id="5-插入删除"><a href="#5-插入删除" class="headerlink" title="5. 插入删除"></a>5. 插入删除</h3><ul>
<li><p>函数原型</p>
<p>两端插入操作</p>
<ol>
<li><code>push_back();</code>//在容器尾部插入一个数据</li>
<li><code>push_front();</code> //在容器头部插入一个数据</li>
<li><code>pop_back();</code>//删除容器最后一个数据</li>
<li><code>pop_front();</code>//删除容器第一个数据</li>
</ol>
<p>指定位置操作</p>
<ol>
<li><code>insert(pos,elem);</code>//在pos位置插入一个elem,返回新数据的位置</li>
<li><code>insert(pos,n,elem);</code>//在pos位置插入n个elem元素，无返回值</li>
<li><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值</li>
<li><code>clear();</code></li>
<li><code>erase(beg,end);</code>//删除[beg,end)区间的数据，无返回值</li>
<li><code>erase(pos);</code>//删除pos位置的元素，返回下一个数据的位置</li>
</ol>
</li>
</ul>
<h3 id="6-数据存取"><a href="#6-数据存取" class="headerlink" title="6. 数据存取"></a>6. 数据存取</h3><ul>
<li>函数原型<ol>
<li><code>at(int idx);</code></li>
<li><code>operator[];</code></li>
<li><code>front();</code></li>
<li><code>back();</code></li>
</ol>
</li>
</ul>
<h3 id="7-排序"><a href="#7-排序" class="headerlink" title="7.排序"></a>7.排序</h3><ul>
<li><p>函数原型</p>
<p><code>sort(iterator beg,iterator end);</code>//默认升序</p>
<p>对于支持随机访问的迭代器的访问，都可以利用sort直接排序</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/05/deque/" data-id="cknhe7bvs003mows6gecrhci9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-优先级队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/03/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2020-03-03T07:50:56.000Z" itemprop="datePublished">2020-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/03/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">优先级队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="STL优先级队列"><a href="#STL优先级队列" class="headerlink" title="STL优先级队列"></a>STL优先级队列</h2><ul>
<li><p>priority_queue:自适应容器（容器适配器），不能使用list</p>
</li>
<li><p>最大值优先级队列：最大的在队列的最前面</p>
</li>
<li><p>最小值优先级队列：最小的在队列最前面</p>
</li>
<li><p>包含的头文件 queue</p>
</li>
<li><p>函数接口</p>
<p>priority_queue&lt;int,deque&lt; int &gt; &gt; pq; //默认最大值优先级队列</p>
<p>priority_queue&lt;int,vector&lt; int &gt; &gt; pq;</p>
<p>priority_queue&lt; int, deque&lt; int &gt;,<strong>greater</strong>&lt; int &gt;&gt; pq;//最小值优先级队列</p>
<p>pq.empty();</p>
<p>pq.size();</p>
<p>pq.top();</p>
<p>pq.pop();</p>
<p>pq.push(item);</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/03/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" data-id="cknhe7bwj0052ows60ikrdbs1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vector容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/29/vector%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-02-29T04:29:13.000Z" itemprop="datePublished">2020-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/29/vector%E5%AE%B9%E5%99%A8/">vector容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vector-容器"><a href="#Vector-容器" class="headerlink" title="Vector 容器"></a>Vector 容器</h2><h3 id="1-vector基本概念"><a href="#1-vector基本概念" class="headerlink" title="1 vector基本概念"></a>1 vector基本概念</h3><ul>
<li><p>功能</p>
<p>vector数据结构和数组十分相似，也称为单端数组</p>
</li>
<li><p>vector和普通数组的区别</p>
<p>不同之处在于数组是静态空间，而vector可以动态扩展</p>
</li>
<li><p>动态扩展</p>
<p><strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</strong></p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/vector.PNG"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h3 id="2-vector构造函数"><a href="#2-vector构造函数" class="headerlink" title="2 vector构造函数"></a>2 vector构造函数</h3><ul>
<li><p>功能描述</p>
<p>创造vector容器</p>
</li>
<li><p>函数原型</p>
<ol>
<li><code>vector &lt;T&gt; v</code>  //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(),v.end());</code>   将v[ begin(), end() ) 区间中的元素拷贝给本身</li>
<li><code>vector(n,elem);</code>    //构造函数将n个elem拷贝给本</li>
<li><code>vector(const vector &amp;vec);</code>   //拷贝构造函数</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	printVector(v1);</span><br><span class="line">	<span class="comment">//通过区间方式构造</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	printVector(v2);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">	printVector(v3);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4(v3);</span><br><span class="line">	printVector(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-vector赋值操作"><a href="#3-vector赋值操作" class="headerlink" title="3 vector赋值操作"></a>3 vector赋值操作</h3><ul>
<li>函数原型<ol>
<li><code>vector&amp; operator=(const vector &amp;vec)</code>  </li>
<li><code>assign(beg,end);</code>  //给[beg, end）区间中的数据拷贝复制给本身</li>
<li><code>assign(n,elem)</code>  //将n个elem拷贝赋值给本身</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  v1.push_back(i);  &#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	printVector(v2);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">	v3.assign(v1.begin(), v1.end());</span><br><span class="line">	printVector(v3);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">	v4.assign(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">	printVector(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-vector容量和大小"><a href="#4-vector容量和大小" class="headerlink" title="4 vector容量和大小"></a>4 vector容量和大小</h3><ul>
<li>函数原型<ol>
<li><code>empty();</code>  //判断容器是否为空</li>
<li><code>capacity();</code>  //容器的容量,<strong>容量大于等于长度</strong></li>
<li><code>size();</code>  //返回容器中元素的个数</li>
<li><code>resize(int num);</code> //重新指定容器的长度为num,若容器边长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
<li><code>resize(int num,elem)</code>  //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。若容器变短，则末尾超出容器长度的元素被删除。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void test03() &#123;</span><br><span class="line">	vector&lt;int&gt;v1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 5; i++) &#123; v1.push_back(i); &#125;</span><br><span class="line">	if (v1.empty())  cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;v1的容量为&quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;v1的大小为&quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;重回新指定大小</span><br><span class="line">	v1.resize(7);</span><br><span class="line">	printVector(v1);&#x2F;&#x2F;0 1 2 3 4 0 0</span><br><span class="line">	v1.resize(10,8);</span><br><span class="line">	printVector(v1);&#x2F;&#x2F;0 1 2 3 4 0 0 8 8 8</span><br><span class="line">	v1.resize(5);</span><br><span class="line">	printVector(v1);&#x2F;&#x2F;0 1 2 3 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-vector插入和删除"><a href="#5-vector插入和删除" class="headerlink" title="5 vector插入和删除"></a>5 vector插入和删除</h3><ul>
<li>函数原型<ol>
<li><code>push_back(elem);</code> //尾部插入元素</li>
<li><code>pop_back();</code>  //删除最后一个元素</li>
<li><code>insert(const_iterator pos,ele);</code>  //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos,int count,ele)；</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>//删除迭代器指向的元素</li>
<li><code>erase(const_iterator start,const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear()</code>；//删除容器中所有的元素</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; v1.push_back(i); &#125;</span><br><span class="line">	v1.pop_back();</span><br><span class="line">	printVector(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.insert(v1.begin(), <span class="number">100</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line">	v1.insert(v1.begin(),<span class="number">2</span>, <span class="number">50</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.erase(v1.end()<span class="number">-1</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line"></span><br><span class="line">	v1.erase(v1.begin(),v1.end()<span class="number">-2</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line">	v1.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-vector数据存取"><a href="#6-vector数据存取" class="headerlink" title="6 vector数据存取"></a>6 vector数据存取</h3><ul>
<li>函数原型<ol>
<li><code>at(int idx);</code>  //返回索引 idx 所值的数据</li>
<li><code>operator[];</code>  //返回索引 idx 所指的数据</li>
<li><code>front();</code>  //返回容器中第一个数据</li>
<li><code>back();</code>  // 返回容器中最后一个数据元素</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; v1.push_back(i); &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素&quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素&quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-vector互换容器"><a href="#7-vector互换容器" class="headerlink" title="7 vector互换容器"></a>7 vector互换容器</h3><ul>
<li><p>函数原型</p>
<p><code>swap(vec);</code>  </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巧用swap可以收缩内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">		v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量为&quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小为&quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	v1.resize(<span class="number">3</span>);<span class="comment">//容量没有变</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量为&quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小为&quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;(v1).swap(v1);</span><br><span class="line">	<span class="comment">//vector &lt;int&gt;(v1)</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量为&quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小为&quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1的容量为<span class="number">138255</span></span><br><span class="line">v1的大小为<span class="number">100000</span></span><br><span class="line">v1的容量为<span class="number">138255</span></span><br><span class="line">v1的大小为<span class="number">3</span></span><br><span class="line">v1的容量为<span class="number">3</span></span><br><span class="line">v1的大小为<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="8-vector预留空间"><a href="#8-vector预留空间" class="headerlink" title="8 vector预留空间"></a>8 vector预留空间</h3><ul>
<li><p>功能描述</p>
<p>减少vector在动态扩展容量时的扩展次数</p>
</li>
<li><p>函数原型</p>
<p><code>reserve(int len);</code> //容器预留len个元素长度，预留位置不初始化，元素不可访问</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//记录动态扩展次数</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="literal">NULL</span>;<span class="comment">//指向当前容器中的首元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//判断指针p所指的首元素地址是否发生变化，如果变化，则重新分配了内存，num加一并更新p</span></span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动态扩展次数：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态扩展次数：<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>使用reserve后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.reserve(<span class="number">300</span>);<span class="comment">//预留空间</span></span><br></pre></td></tr></table></figure>

<p>运算结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态扩展次数：1</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/29/vector%E5%AE%B9%E5%99%A8/" data-id="cknhe7bwe004qows6b5qj4qwq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-string容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/28/string%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-02-28T08:51:23.000Z" itemprop="datePublished">2020-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/28/string%E5%AE%B9%E5%99%A8/">string容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="1-string基本概念"><a href="#1-string基本概念" class="headerlink" title="1 string基本概念"></a>1 string基本概念</h3><p><strong>本质</strong>：</p>
<ul>
<li>string是c++风格的字符串，而string本质上是一个类</li>
</ul>
<p>*<em>string 和 char <em>的区别：</em></em></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char *，管理这个字符串，是一个char * 型的容器</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>string类内部封装了很多成员方法，例如查找find，拷贝copy，删除delete，插入insert</li>
<li>string管理char * 所分配的内存，不用担心复制越界和取值越界，由类内部进行负责</li>
</ul>
<h3 id="2-string-构造函数"><a href="#2-string-构造函数" class="headerlink" title="2 string 构造函数"></a>2 string 构造函数</h3><p>构造函数原型：</p>
<ul>
<li><code>string()</code>     // 创建一个空的字符串，例如 string str;</li>
<li><code>string(const char* s)</code>   //使用字符串 s 初始化 </li>
<li><code>string(const string&amp; str)</code>  //使用一个 string 对象初始化另一个 string 对象</li>
<li><code>string(int n,char c)</code>   //使用 n 个字符 c 初始化</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-string赋值函数"><a href="#3-string赋值函数" class="headerlink" title="3 string赋值函数"></a>3 string赋值函数</h3><ul>
<li><p>赋值的函数原型：</p>
<p>（1）<code>stirng&amp; operator=(const char* s);</code>   //char *类型字符串赋值给当前的字符串</p>
<p>（2）<code>string&amp; operator=(const string &amp;s);</code>  //把字符串 s 赋给当前的字符串</p>
<p>（3）<code>string&amp; operator=(char c);</code>  //字符赋给当前的字符串</p>
<p>（4）<code>string&amp; assign(const char* s);</code>    //把字符串 s 赋给当前的字符串</p>
<p>（5）<code>string&amp; assign(const char* s,int n);</code>    //把字符串 s 的前n个字符赋给当前的字符串</p>
<p>（6）<code>string&amp; assign(const string &amp;s);</code>   //把字符串 s 赋给当前的字符串</p>
<p>（7）<code>string&amp; assign(int n,char c);</code>       //用n个字符 c 赋给当前字符串</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//stirng&amp; operator=(const char* s);  //char *类型字符串赋值给当前的字符串</span></span><br><span class="line">	<span class="built_in">string</span> str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; operator=(const string &amp; s);   //把字符串 s 赋给当前的字符串</span></span><br><span class="line">	<span class="built_in">string</span> str2 = str1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; operator=(char c); //字符赋给当前的字符串</span></span><br><span class="line">	<span class="built_in">string</span> str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; assign(const char* s);   //把字符串 s 赋给当前的字符串</span></span><br><span class="line">	<span class="built_in">string</span> str4;</span><br><span class="line">	str4.assign(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; assign(const char* s, int n);//把字符串 s 的前n个字符赋给当前的字符串</span></span><br><span class="line">	<span class="built_in">string</span> str5;</span><br><span class="line">	str5.assign(<span class="string">&quot;hello c++&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; assign(const string &amp; s);  //把字符串 s 赋给当前的字符串</span></span><br><span class="line">	<span class="built_in">string</span> str6;</span><br><span class="line">	str6.assign(str5);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//string&amp; assign(int n,char c); //用n个字符 c 赋给当前字符串</span></span><br><span class="line">	<span class="built_in">string</span> str7;</span><br><span class="line">	str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-string字符串拼接"><a href="#4-string字符串拼接" class="headerlink" title="4 string字符串拼接"></a>4 string字符串拼接</h3><ul>
<li><p><strong>功能描述</strong></p>
<p>实现在字符串末尾拼接字符串</p>
</li>
<li><p>函数原型</p>
<p>（1）<code>string&amp; operator +=(const char* str);</code>    // 重载+=操作符</p>
<p>（2）<code>string&amp; operator +=(const char c);</code>         // 重载+=操作符</p>
<p>（3）<code>string&amp; operator +=(const string&amp; str);</code>  // 重载+=操作符</p>
<p>（4）<code>string&amp; append(const char *s);</code>    //把字符串s连接到当前字符串结尾</p>
<p>（5）<code>string&amp; append(const char *s，int n);</code>    //把字符串 s 的前n个字符连接到当前字符串结尾</p>
<p>（6）<code>string&amp; append(const string &amp;s);</code>           //同 operator +=(const string&amp; str)</p>
<p>（7）<code>string&amp; append(const string &amp;s,int pos,int n);</code>   //字符串s中从pos开始的n个字符连接到字符串结尾</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//string&amp; operator +=(const char* str);  重载+=操作符</span></span><br><span class="line">	<span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">	str1 += <span class="string">&quot;很好&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; operator +=(const char c);   重载+=操作符</span></span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; operator +=(const string &amp; str); 重载+=操作符</span></span><br><span class="line">	<span class="built_in">string</span> str2 = <span class="string">&quot;加油\n&quot;</span>;</span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; append(const char* s);  把字符串s连接到当前字符串结尾</span></span><br><span class="line">	<span class="built_in">string</span> str3 = <span class="string">&quot;I &quot;</span>;</span><br><span class="line">	str3.append(<span class="string">&quot;Love &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string&amp; append(const char* s，int n);   把字符串 s 的前n个字符连接到当前字符串结尾</span></span><br><span class="line">	str3.append(<span class="string">&quot;Gameabcd&quot;</span>,<span class="number">4</span>);</span><br><span class="line">	<span class="comment">//string&amp; append(const string &amp; s);  同 operator +=(const string&amp; str)</span></span><br><span class="line">	str3.append(str2);</span><br><span class="line">	<span class="comment">//string&amp; append(const string &amp; s, int pos, int n);  字符串s中从pos开始的n个字符连接到字符串结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-string查找和替换"><a href="#5-string查找和替换" class="headerlink" title="5 string查找和替换"></a>5 string查找和替换</h3><ul>
<li><p><strong>功能描述</strong></p>
<p>（1）查找：查找指定字字符串是否存在</p>
<p>（2）替换：在指定的位置替换字符串</p>
</li>
<li><p><strong>函数原型</strong></p>
<p>（1）<code>int  find(const string&amp;  str ,int  pos = 0) const;</code>   //查找 str 第一次出现的位置，从pos开始查找</p>
<p>（2）<code>int find(const char*  s,int pos = 0) const;</code>  //查找 s 第一次出现的位置，从pos开始查找</p>
<p>（3）<code>int find(const char* s, int pos,int n) const;</code>     //从pos位置查找s的前n个字符的第一个位置</p>
<p>（4）<code>int find(const char c,int pos = 0) const；</code>  //查找字符c第一次出现的位置</p>
<p>（5）<code>int rfind(const string&amp; str,int pos = npos) const;</code>    //查找 str 最后一次出现的位置，从pos开始查找</p>
<p>（6）<code>int rfind(const char* s,int pos = npos) const;</code>  //查找 s 最后一次出现的位置，从pos开始查找</p>
<p>（7）<code>int rfind(const char* s, int pos, int n) const;</code>  //从pos位置查找s的前n个字符的最后一个位置</p>
<p>（8）<code>int rfind(const char c,int pos = 0) const</code>    //查找字符c最后一次出现的位置</p>
<p>（9）<code>string&amp; replace(int pos,int n, const string&amp; str);</code>   //替换从pos开始n个字符为字符串str</p>
<p>(10)   <code>string&amp; replace(int pos, int n, const char* s);</code>  //替换从pos开始n个字符为字符串s</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str1 = <span class="string">&quot;abcdefghde&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);<span class="comment">//找到返回位置，是从0开始算，未找到返回-1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	pos = str1.find(<span class="string">&quot;k&quot;</span>);<span class="comment">//找到返回位置，是从0开始算，未找到返回-1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	pos = str1.rfind(<span class="string">&quot;de&quot;</span>);<span class="comment">//从右往左查找</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	<span class="built_in">string</span> str2 = <span class="string">&quot;asdfgh&quot;</span>;</span><br><span class="line">	str2.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);<span class="comment">//从1号位置起三个字符替换为 1111</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-string字符串比较"><a href="#6-string字符串比较" class="headerlink" title="6 string字符串比较"></a>6 string字符串比较</h3><ul>
<li><p><strong>功能函数</strong></p>
<p>字符串之间的比较</p>
</li>
<li><p><strong>比较方式</strong></p>
<p>字符串比较按照字符的ASCII码进行对比</p>
<p>=   返回   0    &gt;  返回   1    &lt;   返回   -1</p>
</li>
<li><p><strong>函数原型</strong></p>
<p>（1）int compare(const  string  &amp;s ) const;   </p>
<p>（2）int compare(const  char *s ) const;   </p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">string</span> str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">string</span> str3 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (str1.compare(str2) == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = str2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (str1.compare(str3) == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 &lt; str2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-string字符存取"><a href="#7-string字符存取" class="headerlink" title="7 string字符存取"></a>7 string字符存取</h3><ul>
<li><p>string单个字符存取方式</p>
<p>（1）<code>char&amp; operator[] (int n)</code>  </p>
<p>（2）<code>char&amp; at(int n)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">	<span class="comment">//读</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	str.at(<span class="number">2</span>) = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-string插入和删除"><a href="#8-string插入和删除" class="headerlink" title="8 string插入和删除"></a>8 string插入和删除</h3><ul>
<li><p>功能描述</p>
<p>对string字符串进行插入和删除字符操作</p>
</li>
<li><p>函数原型</p>
<p>（1）<code>string&amp; insert(int pos,const char* s)</code>    </p>
<p>（2）<code>string&amp; insert(int pos,const string&amp; str)</code>  </p>
<p>（3）<code>string&amp; insert(int pos,int n,char c)</code>    </p>
<p>（4）<code>string&amp; erase(int pos,int n = npos)</code>   //删除从Pos开始的n个字符</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">	str.insert(str.size(), <span class="string">&quot;World&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	str.erase(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-string子串"><a href="#9-string子串" class="headerlink" title="9 string子串"></a>9 string子串</h3><ul>
<li><p>功能描述</p>
<p>从字符串获取想要的子串</p>
</li>
<li><p>函数原型</p>
<p><code>string substr(int pos = 0,int n = npos) const</code>   返回由pos开始的n个字符组成的字符串</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> email = <span class="string">&quot;zhangsan@sina.com&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = email.find(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">	<span class="built_in">string</span> userName = email.substr(<span class="number">0</span>, pos);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;userName = &quot;</span> &lt;&lt; userName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/28/string%E5%AE%B9%E5%99%A8/" data-id="cknhe7bw8004gows61ti5gjhe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-STL初识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/28/STL%E5%88%9D%E8%AF%86/" class="article-date">
  <time datetime="2020-02-28T03:27:40.000Z" itemprop="datePublished">2020-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/28/STL%E5%88%9D%E8%AF%86/">STL初识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="STL-初识"><a href="#STL-初识" class="headerlink" title="STL 初识"></a>STL 初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li>c++的面向对象和泛型编程思想，目的就是复用性的提升。为了简历数据结构和算法的一套标准，诞生了STL。</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL（Standard Template Library）：标准模板库</li>
<li>STL 从广义上理解为：容器（container）、算法（algorithm）、迭代器（iterator）</li>
<li>容器和算法之间通过迭代器进行无缝链接</li>
<li>STL几乎所有的代码都采用模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><ul>
<li><p>STL 大体分为六大组件，分别是容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p>
<p>（1）容器：各种数据结构，如vector、list、deque、set、map等，用来存放函数</p>
<p>（2）算法：各种常用的算法，如sort、find、copy、for_each等</p>
<p>（3）迭代器：扮演了容器和算法之间的胶合剂</p>
<p>（4）仿函数：行为类似函数，可作为算法的某种策略</p>
<p>（5）适配器：一种用来修饰容器或者仿函数或者迭代器接口的东西</p>
<p>（6）空间配置器：负责空间的配置和管理</p>
</li>
</ul>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4 STL中容器、算法、迭代器"></a>2.4 STL中容器、算法、迭代器</h3><h4 id="2-4-1-容器"><a href="#2-4-1-容器" class="headerlink" title="2.4.1 容器"></a>2.4.1 容器</h4><ul>
<li><p>STL 容器就是运用最广泛的一些数据结构实现出来</p>
</li>
<li><p>常用的数据结构：数组、链表、树、栈、队列、集合、映射表等</p>
</li>
<li><p>这些容器分为序列式容器和关联式容器两种：</p>
<p>（1）序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置</p>
<p>（2）关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
</li>
</ul>
<h4 id="2-4-2-算法（algorithm）"><a href="#2-4-2-算法（algorithm）" class="headerlink" title="2.4.2 算法（algorithm）"></a>2.4.2 算法（algorithm）</h4><ul>
<li>质变算法：运算过程中会更改区间内的元素的内容，如拷贝、替换、删除</li>
<li>非质变算法：运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值</li>
</ul>
<h4 id="2-4-3-迭代器"><a href="#2-4-3-迭代器" class="headerlink" title="2.4.3 迭代器"></a>2.4.3 迭代器</h4><ul>
<li><p>提供一种方法，使之能够依次序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
</li>
<li><p>每个容器都有自己专属的迭代器，这种迭代器非常类似于指针。</p>
</li>
<li><p>种类</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><ul>
<li>容器：<code>vector</code></li>
<li>算法：<code>for_each</code></li>
<li>迭代器：<code>vector&lt;int&gt;::iterator</code></li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myprint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个vector容器，数组</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中插入数据</span></span><br><span class="line">	v.push_back(<span class="number">10</span>);</span><br><span class="line">	v.push_back(<span class="number">20</span>);</span><br><span class="line">	v.push_back(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator itBegin = v.begin();<span class="comment">//起始迭代器，指向容器的第一个元素</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator itEnd = v.end();<span class="comment">//结束迭代器，指向容器的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//第一种遍历方式</span></span><br><span class="line">	<span class="keyword">while</span> (itBegin != itEnd) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *itBegin &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		itBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//第二种遍历方式</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//第三种遍历方式</span></span><br><span class="line">	<span class="comment">//参数：起始，结束，自定义函数</span></span><br><span class="line">	for_each(v.begin(),v.end(),Myprint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-vector存放自定义数据类型"><a href="#2-5-2-vector存放自定义数据类型" class="headerlink" title="2.5.2 vector存放自定义数据类型"></a>2.5.2 vector存放自定义数据类型</h4><ul>
<li>vector 存放自定义的类型，并用迭代器输出</li>
</ul>
<p>示例：存放类、指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> m_name;</span><br><span class="line">	<span class="keyword">int</span> m_age;</span><br><span class="line">	Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) :m_name(name), m_age(age) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	<span class="comment">//遍历容器中的数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Person*&gt; v;<span class="comment">//容器中存放指针</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	v.push_back(&amp;p1);<span class="comment">//传地址</span></span><br><span class="line">	v.push_back(&amp;p2);</span><br><span class="line">	v.push_back(&amp;p3);</span><br><span class="line">	<span class="comment">//遍历容器中的数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">		<span class="comment">//it 是指向容器元素的指针，*it则是容器中的元素值，即指向对象的指针</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*it)-&gt;m_age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*it)-&gt;m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-vector容器嵌套容器"><a href="#2-5-4-vector容器嵌套容器" class="headerlink" title="2.5.4 vector容器嵌套容器"></a>2.5.4 vector容器嵌套容器</h4><ul>
<li>容器中嵌套容器，将所有数据遍历输出</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">		v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">		v3.push_back(i + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v.push_back(v1);</span><br><span class="line">	v.push_back(v2);</span><br><span class="line">	v.push_back(v3);</span><br><span class="line">	<span class="comment">//遍历所有数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt;::iterator It = v.begin(); It != v.end(); It++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = (*It).begin(); it != (*It).end(); it++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/28/STL%E5%88%9D%E8%AF%86/" data-id="cknhe7bve002wows6hdut7jxu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-函数调用运算符重载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/28/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="article-date">
  <time datetime="2020-02-28T03:13:33.000Z" itemprop="datePublished">2020-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/28/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">函数调用运算符重载(基础)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数调用运算符重载-基础"><a href="#函数调用运算符重载-基础" class="headerlink" title="函数调用运算符重载(基础)"></a>函数调用运算符重载(基础)</h2><ul>
<li>函数调用运算符 （）也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为<strong>仿函数</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//打印类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyPrint Myprint;</span><br><span class="line">	Myprint(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//重载函数调用</span></span><br><span class="line">	MyAdd Myadd;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Myadd(100, 100) = &quot;</span> &lt;&lt; Myadd(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//匿名函数对象</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Myadd()(100, 100) = &quot;</span> &lt;&lt; MyAdd()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/28/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" data-id="cknhe7bwr005lows601smbbz3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-运算符重载-赋值运算符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/27/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time datetime="2020-02-27T13:04:02.000Z" itemprop="datePublished">2020-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/27/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符重载(赋值运算符)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><ul>
<li><p>c++ 编译器至少给一个类添加四个函数</p>
<p>（1）默认构造函数（无参，函数体为空）</p>
<p>（2）默认析构函数（无参，函数体为空）</p>
<p>（3）默认拷贝构造函数，对属性进行值拷贝</p>
<p>（4）赋值运算符 operator= ，对属性进行值拷贝</p>
</li>
<li><p>如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝问题</p>
</li>
<li><p>在c++中为了实现连等，所以函数返回值为自身，并且可以提高效率，减少临时对象的开销。</p>
</li>
</ul>
<p>示例：c++中内置连等，其运算结果为 a = 2  b = 1  c = 2，显然在执行完括号内赋值后返回了 a 本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">(a = b) = c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>重载实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> *m_age;</span><br><span class="line">	Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//深拷贝</span></span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_age);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回自身，实现连等运算</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1的年龄：&quot;</span> &lt;&lt; *p1.m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2的年龄：&quot;</span> &lt;&lt; *p2.m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3的年龄：&quot;</span> &lt;&lt; *p3.m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/27/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="cknhe7bxz008bows6fhv89et2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-运算符重载-递增运算符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/27/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time datetime="2020-02-27T10:49:12.000Z" itemprop="datePublished">2020-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/27/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符重载(递增运算符)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="递增操作符的重载"><a href="#递增操作符的重载" class="headerlink" title="递增操作符的重载"></a>递增操作符的重载</h2><ul>
<li><p>前置递增：比如 ++i：先对 i 进行加一操作，i++：返回的是 i 自增之前的值</p>
</li>
<li><p>++i 的返回是可修改值，然而 i++ 的返回是不可以修改的值。</p>
<p>（1）（i++）++ ； 编译错误</p>
<p>（2）（++i）++ ； 编译通过</p>
</li>
<li><p>重载代码实现：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInt</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; <span class="built_in">cout</span>, MyInt p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyInt(<span class="keyword">int</span> num) :m_num(num)&#123; &#125;</span><br><span class="line">	<span class="comment">//重载 前置++运算符</span></span><br><span class="line">	MyInt&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//先加1，后返回</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_num += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回解引用，即返回自身，实现链式递增</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载 后置++运算符</span></span><br><span class="line">	<span class="comment">//c++中要求：int 代表占位参数，用来区分前置和后置</span></span><br><span class="line">	<span class="keyword">const</span> MyInt <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="comment">//把旧的先复制一份，在把原来的加一，最后将复制的那份返回去。</span></span><br><span class="line">		MyInt temp = *<span class="keyword">this</span>;<span class="comment">//先记录当前结果</span></span><br><span class="line">		m_num++;<span class="comment">//递增</span></span><br><span class="line">		<span class="keyword">return</span> temp;<span class="comment">//返回记录结果</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; <span class="built_in">cout</span>, MyInt p) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.m_num;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">MyInt <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ++p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">MyInt <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前置后置的区别"><a href="#前置后置的区别" class="headerlink" title="前置后置的区别"></a>前置后置的区别</h2><ul>
<li><p><strong>返回值</strong></p>
<p>前置递增返回的是操作对象自身，所以返回值类型是引用。</p>
<p>后置递增返回的是局部对象，并且因为c++自身实现的后置递增运算 <code>i++</code> 是不可修改的，所以返回值是 <strong>const 对象</strong>，否则像 <code>(i++)++</code> 这样的代码是可以通过编译的，让人误以为真的可以实现递增两次，实际上是不可以的，第一次递增作用在自身，第二次是作用在返回的临时对象上。</p>
</li>
<li><p><strong>效率</strong></p>
<p>后置递增相比前置递增而言，增加了一个临时对象的创建，就会多出构造和析构的开销，效率便不如前置递增。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/27/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="cknhe7by2008dows6eze8eoaj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">Java设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaweb/" rel="tag">javaweb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Java设计模式</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/SSM/" style="font-size: 15px;">SSM</a> <a href="/tags/c/" style="font-size: 16.67px;">c++</a> <a href="/tags/javaweb/" style="font-size: 18.33px;">javaweb</a> <a href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" style="font-size: 13.33px;">《数据库系统概论》</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/21/spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">spring的依赖注入</a>
          </li>
        
          <li>
            <a href="/2021/04/19/spring%E7%9A%84IOC/">spring的IOC和实例化bean的配置</a>
          </li>
        
          <li>
            <a href="/2021/04/16/MyBatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/">MyBatis注解开发</a>
          </li>
        
          <li>
            <a href="/2021/04/15/MyBatis%E7%BC%93%E5%AD%98/">MyBatis缓存</a>
          </li>
        
          <li>
            <a href="/2021/04/14/MyBatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/">MyBatis延迟加载</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 hxx-98<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>