<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hxx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hxx">
<meta property="og:url" content="http://hxx-98.github.io/page/12/index.html">
<meta property="og:site_name" content="Hxx">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hxx-98">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hxx" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hxx</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hxx-98.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据库复习笔记七" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/" class="article-date">
  <time datetime="2020-03-13T07:18:53.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/">《数据库系统概论》(王珊  萨师煊)复习笔记（七）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h1><h2 id="1-事务的基本概念"><a href="#1-事务的基本概念" class="headerlink" title="1  事务的基本概念"></a>1  事务的基本概念</h2><ul>
<li><strong>定义</strong><ul>
<li>一个数据库操作序列</li>
<li>一个不可分割的工作单位（要么全做，要么不做）</li>
<li>恢复和并发控制的基本单位</li>
</ul>
</li>
<li><strong>事务和程序比较</strong><ul>
<li>在关系数据库中，一个事务可以是一条或多条SQL语句,也可以包含一个或多个程序。</li>
<li>一个程序通常包含多个事务</li>
</ul>
</li>
<li><strong>事务的特性</strong><ul>
<li><strong>原子性</strong>（Atomicity）<br>事务中的所有操作要么全部执行，要么都不执行。</li>
<li><strong>一致性</strong>（Consistency）<br>如果在执行事务之前数据库是一致的，那么在执行事务之后数据库也还应该是一致的。</li>
<li><strong>隔离性</strong>（Isolation）<br>即使多个事务并发执行，每个事务都感觉不到系统中有其他事务在执行，以保证数据库的一致性。</li>
<li><strong>持续性</strong>（Durability ）<br>事务成功执行后它对数据库的修改是永久的，即使系统出现故障。</li>
</ul>
</li>
</ul>
<h2 id="2-数据库恢复概述"><a href="#2-数据库恢复概述" class="headerlink" title="2  数据库恢复概述"></a>2  数据库恢复概述</h2><ul>
<li><p>故障是不可避免的</p>
<ul>
<li>系统故障：计算机软、硬件故障</li>
<li>人为故障：操作员的失误、恶意的破坏等。</li>
</ul>
</li>
<li><p>数据库的恢复</p>
<pre><code>* 把数据库从错误状态恢复到某一已知的正确状态(亦称为**一致状态或完整状态**)</code></pre>
<ul>
<li>恢复子系统是DBMS的一个重要组成部分，而且相当庞大</li>
</ul>
</li>
</ul>
<h2 id="3-故障的种类"><a href="#3-故障的种类" class="headerlink" title="3  故障的种类"></a>3  故障的种类</h2><ul>
<li>事务内部的故障<ul>
<li>事务内部更多的故障是非预期的，不能由应用程序处理<ul>
<li>运算溢出</li>
<li>并发事务发生死锁</li>
<li>违反了某些完整性限制等</li>
<li>事务故障仅指这类非预期的故障</li>
</ul>
</li>
<li>事务故障的恢复：<strong>撤消事务（UNDO）</strong></li>
</ul>
</li>
<li>系统故障<ul>
<li>系统故障：称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。 如：<ul>
<li>特定类型的硬件错误（如CPU故障）</li>
<li>操作系统故障</li>
<li>DBMS代码错误</li>
<li>系统断电</li>
</ul>
</li>
<li>后果<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止</li>
<li>内存中数据库缓冲区的信息全部丢失</li>
<li>不破坏数据库</li>
</ul>
</li>
<li><strong>发生系统故障时，事务未提交</strong><br><strong>恢复策略：强行撤消（UNDO）所有未完成事务</strong></li>
<li><strong>发生系统故障时，事务已提交，但缓冲区中的信息尚未完全写回到磁盘上。</strong><br><strong>恢复策略：重做（REDO）所有已提交的事务</strong></li>
</ul>
</li>
<li>介质故障<ul>
<li>称为硬故障，指外存故障<ul>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>操作系统的某种潜在错误</li>
<li>瞬时强磁场干扰</li>
</ul>
</li>
<li>介质故障的恢复<ul>
<li>装入数据库发生介质故障前某个时刻的数据副本</li>
<li>重做自此时始的所有成功事务，将这些事务已提交的结果重新记入数据库</li>
</ul>
</li>
</ul>
</li>
<li>计算机病毒<ul>
<li>计算机病毒<br>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序<br>可以繁殖和传播</li>
<li>危害<br>破坏、盗窃系统中的数据<br>破坏系统文件</li>
</ul>
</li>
</ul>
<h2 id="4-恢复的实现技术"><a href="#4-恢复的实现技术" class="headerlink" title="4  恢复的实现技术"></a>4  恢复的实现技术</h2><ul>
<li><p><strong>恢复操作的基本原理</strong>：冗余</p>
<p>利用存储在系统其它地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据</p>
</li>
<li><p><strong>恢复机制涉及的关键问题</strong></p>
<ul>
<li>如何建立冗余数据<br>数据转储（backup）<br>登录日志文件（logging）</li>
<li>如何利用这些冗余数据实施数据库恢复</li>
</ul>
</li>
<li><p><strong>转储</strong></p>
<ul>
<li>DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程，备用的数据称为后备副本或后援副本。</li>
<li>如何使用<br>数据库遭到破坏后可以将后备副本重新装入<br>重装后备副本只能将数据库恢复到转储时的状态</li>
<li><strong>静态转储</strong><ul>
<li>在系统中无运行事务时进行的转储操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>转储期间不允许对数据库的任何存取、修改活动</li>
<li>优点<ul>
<li>实现简单</li>
<li>得到的一定是一个数据一致性的副本 </li>
</ul>
</li>
<li>缺点：降低了数据库的可用性<ul>
<li>转储必须等待正运行的用户事务结束 </li>
<li>新的事务必须等转储结束</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态存储</strong><ul>
<li>转储操作与用户事务并发进行</li>
<li>转储期间允许对数据库进行存取或修改</li>
<li>优点<ul>
<li>不用等待正在运行的用户事务结束</li>
<li>不会影响新事务的运行</li>
</ul>
</li>
<li>动态转储的缺点<ul>
<li>不能保证副本中的数据正确有效</li>
<li>例如：在转储期间的某个时刻Tc，系统把数据A=100转储到磁带上，而在下一时刻Td，某一事务将A改为200。转储结束后，后备副本上的A已是过时的数据了</li>
</ul>
</li>
<li>利用动态转储得到的副本进行故障恢复<ul>
<li>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件</li>
<li>后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态</li>
</ul>
</li>
</ul>
</li>
<li><strong>海量转储与增量转储</strong><ul>
<li>海量转储（完全转储）: 每次转储全部数据库</li>
<li>增量转储: 只转储上次转储后更新过的数据</li>
<li>海量转储与增量转储比较<ul>
<li>从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便</li>
<li>但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>登记日志文件</strong></p>
<ul>
<li><p>什么是日志文件<br>日志文件(log)是用来记录事务对数据库的更新操作的文件</p>
</li>
<li><p>日志文件的格式</p>
<ul>
<li>以记录为单位的日志文件<ul>
<li>各个事务的开始标记(BEGIN TRANSACTION)</li>
<li>各个事务的结束标记(COMMIT或ROLLBACK)</li>
<li>各个事务的所有更新操作</li>
</ul>
</li>
<li>以数据块为单位的日志文件<ul>
<li>事务标识（标明是那个事务）</li>
<li>被更新的数据块</li>
</ul>
</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</li>
<li><p>基本原则</p>
<p>登记的次序严格按并行事务执行的时间次序<br>必须先写日志文件，后写数据库</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-恢复策略"><a href="#5-恢复策略" class="headerlink" title="5  恢复策略"></a>5  恢复策略</h2><ul>
<li><strong>事务故障的恢复</strong><ul>
<li>事务故障：事务在运行至正常终止点前被终止</li>
<li>恢复方法<br>由恢复子系统应利用日志文件撤消（UNDO）此事务已对数据库进行的修改</li>
<li>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</li>
</ul>
</li>
<li><strong>系统故障的恢复</strong><ul>
<li>系统故障造成数据库不一致状态的原因<br>未完成事务对数据库的更新已写入数据库<br>已提交事务对数据库的更新还留在缓冲区没来得及写入数据库</li>
<li>恢复方法<ol>
<li>Undo 故障发生时未完成的事务</li>
</ol>
</li>
<li>恢复方法<ol>
<li>Undo 故障发生时未完成的事务</li>
<li>Redo 已完成的事务</li>
</ol>
</li>
<li>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li>
</ul>
</li>
<li><strong>介质故障的恢复</strong><ul>
<li>重装数据库</li>
<li>重做已完成的事务</li>
</ul>
</li>
</ul>
<h2 id="6-具有检查点的恢复技术"><a href="#6-具有检查点的恢复技术" class="headerlink" title="6  具有检查点的恢复技术"></a>6  具有检查点的恢复技术</h2><ul>
<li>具有检查点（checkpoint）的恢复技术<ul>
<li>在日志文件中增加检查点记录（checkpoint）</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志</li>
</ul>
</li>
</ul>
<h2 id="7-数据库镜像"><a href="#7-数据库镜像" class="headerlink" title="7  数据库镜像"></a>7  数据库镜像</h2><ul>
<li><p>数据库镜像</p>
<ul>
<li>DBMS自动把整个a数据库或其中的关键数据复制到另一个磁盘上</li>
<li>DBMS自动保证镜像数据与主数据库的一致性</li>
<li>每当主数据库更新时，DBMS自动把更新后的数据复制过去</li>
</ul>
</li>
<li><p>出现介质故障时</p>
<ul>
<li>可由镜像磁盘继续提供使用 </li>
<li>同时DBMS自动利用镜像磁盘数据进行数据库的恢复</li>
<li>不需要关闭系统和重装数据库副本</li>
</ul>
</li>
<li><p>没有出现故障时</p>
<ul>
<li>可用于并发操作</li>
<li>一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁 </li>
</ul>
</li>
<li><p>频繁地复制数据自然会降低系统运行效率</p>
<ul>
<li>在实际应用中用户往往只选择对关键数据和日志文件镜像，而不是对整个数据库进行镜像</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/" data-id="cknhe7bxb006vows65fvl74xd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记六" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/" class="article-date">
  <time datetime="2020-03-13T06:33:56.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/">《数据库系统概论》(王珊  萨师煊)复习笔记（六）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><h2 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1  数据库设计概述"></a>1  数据库设计概述</h2><ul>
<li><strong>数据库设计</strong><br>数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</li>
<li><strong>设计阶段</strong><ul>
<li><strong>需求分析</strong><ul>
<li>准确了解与分析用户需求（包括数据与处理）</li>
</ul>
</li>
<li><strong>概念结构设计</strong><ul>
<li>整个数据库设计的关键</li>
<li>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型</li>
</ul>
</li>
<li><strong>逻辑结构设计</strong><ul>
<li>将概念结构转换为某个DBMS所支持的数据模型</li>
<li>对其进行优化</li>
</ul>
</li>
<li><strong>物理结构设计</strong><ul>
<li>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</li>
</ul>
</li>
<li><strong>数据库实施</strong><ul>
<li>运用DBMS提供的数据库语言（如SQL）及宿主语言，根据逻辑设计和物理设计的结果<ul>
<li>建立数据库</li>
<li>编制与调试应用程序</li>
<li>组织数据入库</li>
<li>进行试运行</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据库运行和维护</strong> <ul>
<li>数据库应用系统经过试运行后即可投入正式运行</li>
<li>在数据库系统运行过程中必须不断地对其进行评价、调整与修改</li>
</ul>
</li>
</ul>
</li>
<li>需求分析和概念设计独立于任何数据库管理系统</li>
<li>逻辑设计和物理设计与选用的DBMS密切相关</li>
</ul>
<h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2  需求分析"></a>2  需求分析</h2><ul>
<li><p>详细调查现实世界要处理的对象（组织、部门、企业等）</p>
<ul>
<li>充分了解原系统（手工系统或计算机系统）</li>
<li>明确用户的各种需求</li>
<li>确定新系统的功能</li>
<li>充分考虑今后可能的扩充和改变</li>
</ul>
</li>
<li><p>调查的重点是“数据”和“处理”，获得用户对数据库要求</p>
<ul>
<li>信息要求</li>
<li>处理要求</li>
<li>安全性与完整性要求</li>
</ul>
</li>
<li><p>结构化分析方法（Structured Analysis，简称SA方法）</p>
<ul>
<li><p>从最上层的系统组织机构入手</p>
</li>
<li><p>自顶向下、逐层分解分析系统</p>
</li>
<li><p>首先把任何一个系统都抽象为：</p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%8A%BD%E8%B1%A1.PNG"></p>
<ul>
<li><p>分解处理功能和数据</p>
<ul>
<li><p>分解处理功能</p>
<p> 将处理功能的具体内容分解为若干子功能</p>
</li>
<li><p>分解数据<br>处理功能逐步分解同时，逐级分解所用数据，形成若干层次的<strong>数据流图</strong></p>
</li>
<li><p>表达方法<br> 处理逻辑：用判定表或判定树来描述<br> 数据：用数据字典来描述</p>
</li>
</ul>
</li>
<li><p>将分析结果再次提交给用户，征得用户的认可</p>
</li>
</ul>
</li>
<li><p>数据字典</p>
<ul>
<li>数据字典的用途<br>进行详细的数据收集和数据分析所获得的主要结果</li>
<li>数据字典的内容<br>数据项：不可再分的数据单位<br>数据结构：反映了数据项之间的组合关系<br>数据流：数据结构在系统内传输的路径。<br>数据存储：数据结构停留或保存的地方<br>处理过程：说明性信息的描述</li>
</ul>
</li>
</ul>
<h2 id="3-概念结构设计"><a href="#3-概念结构设计" class="headerlink" title="3  概念结构设计"></a>3  概念结构设计</h2><ul>
<li><p>什么是概念结构设计</p>
<ul>
<li>将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计</li>
<li>概念结构是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定</li>
<li>概念结构设计是整个数据库设计的关键</li>
</ul>
</li>
<li><p>概念结构设计的特点</p>
<ul>
<li>能真实、充分地反映现实世界</li>
<li>易于理解</li>
<li>易于更改</li>
<li>易于向关系、网状、层次等各种数据模型转换</li>
</ul>
</li>
<li><p>描述概念模型的工具：<strong>E-R模型</strong></p>
</li>
<li><p>设计概念结构的四类方法</p>
<ul>
<li>自顶向下</li>
<li>自底向上</li>
<li>逐步扩张</li>
<li>混合策略</li>
</ul>
</li>
<li><p>数据抽象</p>
<p>分类、聚集、概括</p>
</li>
</ul>
<h2 id="4-逻辑结构设计"><a href="#4-逻辑结构设计" class="headerlink" title="4  逻辑结构设计"></a>4  逻辑结构设计</h2><ul>
<li>逻辑结构设计的任务<br>把概念结构设计阶段设计好的基本E-R图转换为与选用DBMS产品所支持的数据模型相符合的逻辑结构</li>
<li>逻辑结构设计的步骤</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png"></p>
<ul>
<li>E-R图向关系模型的转换要解决的问题<br>如何将实体型和实体间的联系转换为关系模式<br>如何确定这些关系模式的属性和码 </li>
<li>转换内容<br>将E-R图转换为关系模型：将实体、实体的属性和实体之间的联系转换为关系模式。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/" data-id="cknhe7bxe0071ows61rco9aan" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记五" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/" class="article-date">
  <time datetime="2020-03-13T03:07:52.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/">《数据库系统概论》(王珊  萨师煊)复习笔记（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h1><h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><h2 id="1-理论依据"><a href="#1-理论依据" class="headerlink" title="1 理论依据"></a>1 理论依据</h2><ul>
<li>数据依赖：函数依赖、多值依赖、范式（NF）</li>
</ul>
<h2 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2 规范化"></a>2 规范化</h2><h3 id="2-1-理论"><a href="#2-1-理论" class="headerlink" title="2.1 理论"></a><strong>2.1 理论</strong></h3><p>规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。</p>
<h3 id="2-2-关系模式"><a href="#2-2-关系模式" class="headerlink" title="2.2 关系模式"></a><strong>2.2 关系模式</strong></h3><ul>
<li><p>由五部分组成，即它是一个五元组：R(U, D, DOM, F)</p>
<ul>
<li>R：关系名</li>
<li>U：组成该关系的属性名集合</li>
<li>D：属性组U中属性所来自的域</li>
<li>DOM：属性向域的映象集合</li>
<li>F：属性间数据的依赖关系集合</li>
</ul>
</li>
<li><p>简化为一个三元组：R(U, F)</p>
</li>
</ul>
<h3 id="2-3-数据依赖"><a href="#2-3-数据依赖" class="headerlink" title="2.3 数据依赖"></a><strong>2.3 数据依赖</strong></h3><ul>
<li>客观世界中事物间的联系：<ul>
<li>实体与实体的联系——数据模型 </li>
<li>实体内部属性间的联系——数据依赖 </li>
</ul>
</li>
<li>属性间的联系分为三类：一对一 、一对多、多对多</li>
<li>数据依赖：关系中属性值之间相互依赖相互制约的联系。</li>
<li>属性间的数据依赖类型主要有两种：<ul>
<li>函数依赖</li>
<li>多值依赖</li>
</ul>
</li>
</ul>
<h3 id="2-4-函数依赖"><a href="#2-4-函数依赖" class="headerlink" title="2.4 函数依赖"></a><strong>2.4 函数依赖</strong></h3><ul>
<li><p>定义：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”，记作X→Y。  </p>
</li>
<li><p><strong>平凡函数依赖与非平凡函数依赖</strong></p>
<ul>
<li>在关系模式R(U)中，对于U的子集X和Y，<br>如果X→Y，但Y 包含于 X，则称X→Y是非平凡的函数依赖<br>若X→Y，但Y 不包含于X,   则称X→Y是平凡的(trivial)函数依赖</li>
<li>在关系SC(Sno, Cno, Grade)中，<br> 非平凡函数依赖： (Sno, Cno) → Grade<br> 平凡函数依赖：     (Sno, Cno) → Sno    (Sno, Cno) → Cno</li>
<li>若X→Y，则X称为这个函数依赖的决定属性组，也称为决定因素<br>若X→Y，Y→X，则记作X←→Y。</li>
</ul>
</li>
<li><p><strong>完全函数依赖与部分函数依赖</strong></p>
<ul>
<li>定义在R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有Y不函数依赖于X’, 则称Y对X完全函数依赖，记作</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%AE%8C%E5%85%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.PNG"></p>
<ul>
<li>若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.PNG"></p>
</li>
<li><p><strong>传递函数依赖</strong></p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.PNG"></p>
</li>
<li><p><strong>属性间的联系决定函数依赖关系</strong></p>
<ul>
<li><p>X、Y有1:1关系，则X→Y，Y→X。可表示成：X←→Y。</p>
</li>
<li><p>X、Y有1:m关系，则Y→X,但X不函数依赖于Y。（如班主任：学</p>
<p>生，则学生→班主任，但班主任不函数依赖于学生）</p>
</li>
<li><p>X、Y有n:m关系，则X与Y不存在任何函数依赖。</p>
</li>
</ul>
</li>
<li><p><strong>举例</strong></p>
<ul>
<li><p>建立一个描述学生的数据库：</p>
<ul>
<li><p>学生的学号（Sno）、所在系（Sdept）、学生住处（Sloc）、课程号（Cno）、成绩（Grade）</p>
</li>
<li><p>单一的关系模式 ：   Student &lt;U、F&gt;<br>U ＝｛ Sno, Sdept, Sloc, Cno, Grade ｝</p>
<p>F ＝｛ Sno → Sdept,  Sdept → Sloc,  (Sno, Cno) → Grade ｝</p>
</li>
<li><p>Sno → Sdept，Sdept → Sloc   Sloc传递函数依赖于Sno</p>
</li>
<li><p>(Sno,Cno)→Grade是完全函数依赖，</p>
</li>
<li><p>(Sno,Cno)→Sdept是部分函数依赖， 因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-码"><a href="#2-5-码" class="headerlink" title="2.5 码"></a><strong>2.5 码</strong></h3><ul>
<li>候选码</li>
<li>主码</li>
<li>主属性和非主属性</li>
<li>全码</li>
<li>外部码</li>
</ul>
<h3 id="2-6-范式"><a href="#2-6-范式" class="headerlink" title="2.6 范式"></a><strong>2.6 范式</strong></h3><ul>
<li><p>各种范式之间存在联系：</p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%8C%83%E5%BC%8F.png"></p>
</li>
<li><p>某一关系模式R为第n范式，可简记为R∈nNF。</p>
</li>
<li><p>一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong> </p>
</li>
</ul>
<h3 id="2-7-1NF"><a href="#2-7-1NF" class="headerlink" title="2.7 1NF"></a>2.7 1NF</h3><ul>
<li><p>1NF的定义：如果模一个关系式R的所有属性都是不可分的基本数据项，则R∈1NF</p>
</li>
<li><p>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库，但是满足第一范式的关系模式并不一定是一个好的关系模式</p>
<ul>
<li>关系模式 S-L-C(Sno, Sdept, Sloc, Cno, Grade) </li>
<li>函数依赖</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/1NF.PNG"></p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/2NF%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.PNG"></p>
<ul>
<li>S-L-C的码为(Sno, Cno)<br>S-L-C满足第一范式。<br>非主属性Sdept和Sloc部分函数依赖于码(Sno, Cno)</li>
</ul>
</li>
</ul>
<h3 id="2-8-2NF"><a href="#2-8-2NF" class="headerlink" title="2.8 2NF"></a>2.8 2NF</h3><ul>
<li><p><strong>若R∈1NF，且每一个非主属性完全函数依赖于码，则R∈2NF。</strong></p>
<ul>
<li><p>S-L-C(Sno, Cno, Sdept, Sloc, Grade)</p>
<p>插入异常：插入一个学生，还未选课</p>
<p>删除异常：删除一个学生选的唯一课程</p>
<p>数据冗余度大：一个学生选修k门课，Sdept、Sloc重复存储k次</p>
</li>
</ul>
</li>
<li><p>原因：dept、 Sloc<strong>部分函数依赖</strong>于码。</p>
</li>
<li><p>解决方法：S-L-C分解为两个关系模式，以消除这些部分函数依赖 </p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/2NF%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.PNG"></p>
<ul>
<li>关系模式SC的码为（Sno，Cno）<br>关系模式S-L的码为Sno<br>这样非主属性对码都是完全函数依赖 </li>
</ul>
</li>
</ul>
<h3 id="2-9-3NF"><a href="#2-9-3NF" class="headerlink" title="2.9 3NF"></a>2.9 3NF</h3><ul>
<li><p><strong>若R∈3NF，则每一个非主属性既不部分依赖于码，也不传递依赖于码。</strong></p>
<ul>
<li>S-L中存在非主属性对码的传递函数依赖，若一个系换学生宿舍楼，则修改复杂</li>
<li>采用投影分解法，把S-L分解为两个关系模式，以消除传递函数依赖,S-D的码为Sno， D-L的码为Sdept。分解后的关系模式S-D与D-L中不再存在传递依赖 </li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/3NF.PNG"></p>
</li>
</ul>
<h3 id="2-10-BCNF"><a href="#2-10-BCNF" class="headerlink" title="2.10 BCNF"></a>2.10 BCNF</h3><ul>
<li><p><strong>每一个决定属性因素都包含码，没有任何属性对码的部分函数依赖和传递函数依赖</strong></p>
</li>
<li><p>若R∈BCNF </p>
<ul>
<li><p>所有非主属性对每一个码都是完全函数依赖</p>
</li>
<li><p>所有的主属性对每一个不包含它的码，也是完全函数依赖</p>
</li>
<li><p>没有任何属性完全函数依赖于非码的任何一组属性</p>
</li>
<li><p>在关系模式STJ（S，T，J）中，S表示学生，T表示教师，J表示课程。</p>
<ul>
<li>函数依赖：(S，J)和(S，T)都是候选码</li>
<li>STJ∈3NF ，没有任何非主属性对码传递依赖或部分依赖 </li>
<li>STJ不属于BCNF，T是决定因素，T不包含码</li>
</ul>
<p>​              (S，J)→T</p>
<p>​              (S，T)→J</p>
<p>​               T→J</p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/STJ%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.PNG"></p>
<ul>
<li><p>解决方法：将STJ分解为二个关系模式：ST(S，T) ∈ BCNF， TJ(T，J)∈ BCNF</p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/BCNF.PNG"></p>
</li>
</ul>
</li>
<li><p>已知一个关系模式的属性之间的语义，也就是相互依赖的关系，如何判断该模式满足第几范式？</p>
<ul>
<li>首先要通过语义把属性之间的函数依赖关系列出来，</li>
<li>然后确定哪些属性组合可以候选码，从而找出非主属性和主属性。</li>
<li>然后判断是否存在非主属性与码之间的<strong>部分函数依赖</strong>关系，如果存在，则不满足2NF，如不存在部分函数依赖，则属于2NF，</li>
<li>继续进行下一步判断；判断非主属性与码之间存在<strong>传递依赖关系</strong>，不存在，则为3NF；</li>
<li><strong>决定因素是否包含码</strong>，满足条件则为BCNF </li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%A7%84%E8%8C%83%E6%AD%A5%E9%AA%A4.PNG"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/" data-id="cknhe7bxd0070ows6ftsf7xtj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记四" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/" class="article-date">
  <time datetime="2020-03-13T01:57:05.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/">《数据库系统概论》(王珊  萨师煊)复习笔记（四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第四章-数据库保护"><a href="#第四章-数据库保护" class="headerlink" title="第四章 数据库保护"></a>第四章 数据库保护</h1><h2 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h2><ol>
<li>非法使用数据库的情况<ul>
<li>编写合法程序绕过及DBMS其授权机制</li>
<li>直接或编写应用程序执行非授权操作</li>
<li>通过多次合法查询数据库从中推导出一些保密数据</li>
</ul>
</li>
<li>计算机系统中，安全措施是一级一级层层设置</li>
<li>计算机系统的安全模型</li>
</ol>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.PNG"></p>
<ol start="4">
<li><p>用户识别和鉴别</p>
<ul>
<li>用户标识与鉴别：系统提供的最外层安全保护措施</li>
<li>用户标识：用户名、用户标识号</li>
<li>口令：系统核对口令以鉴别用户身份 </li>
<li>用户名和口令易被窃取：每个用户预先约定好一个计算过程或者函数</li>
</ul>
</li>
<li><p>存取控制</p>
<ul>
<li>存取控制机制组成：定义用户权限、合法权限检查 。用户权限定义和合法权检查机制一起组成了DBMS的安全子系统</li>
<li>常用存取控制方法<ul>
<li>自主存取控制（Discretionary Access Control ，简称DAC）<br> C2级<br> 灵活</li>
<li>强制存取控制（Mandatory Access Control，简称 MAC）<br>B1级<br>严格</li>
</ul>
</li>
<li>用户权限组成：数据对象、操作类型</li>
<li>定义用户存取权限：定义哪些用户可以在哪些数据库对象上进行哪些类型的操作，是策略问题，DBMS应提供机制</li>
<li>关系数据库系统中存取控制对象 </li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1.PNG"></p>
</li>
<li><p>授权与回收</p>
<ul>
<li><p>GRANT</p>
<ul>
<li>GRANT语句的一般格式：      </li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]... </span><br><span class="line">      [<span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;]</span><br><span class="line">      <span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">      [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>语义：将对指定操作对象的指定操作权限授予指定的用户 </p>
</li>
<li><p>发出GRANT的用户：</p>
<ul>
<li>DBA</li>
<li>数据库对象创建者（即属主Owner）</li>
<li>拥有该权限的用户</li>
</ul>
</li>
<li><p>按受权限的用户 </p>
<ul>
<li>一个或多个具体用户</li>
<li>PUBLIC（全体用户）  </li>
</ul>
</li>
<li><p>WITH GRANT OPTION子句:</p>
<ul>
<li>指定：可以再授予</li>
<li>没有指定：不能传播</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把查询Student表权限授给用户U1*/</span></span><br><span class="line">	<span class="keyword">GRANT</span>   <span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">ON</span>   <span class="keyword">TABLE</span>   Student </span><br><span class="line">    <span class="keyword">TO</span>   U1;</span><br><span class="line"><span class="comment">/*把对Student表和Course表的全部权限授予用户U2和U3*/</span></span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">TABLE</span> Student, Course </span><br><span class="line">    <span class="keyword">TO</span> U2, U3;</span><br><span class="line"><span class="comment">/*把对表SC的查询权限授予所有用户*/</span></span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line">	<span class="keyword">TO</span> <span class="keyword">PUBLIC</span>;</span><br><span class="line"><span class="comment">/*把查询Student表和修改学生学号的权限授给用户U4*/</span></span><br><span class="line">	<span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(Sno), <span class="keyword">SELECT</span> </span><br><span class="line">	<span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line">	<span class="keyword">TO</span> U4;</span><br><span class="line"><span class="comment">/*属性列的授权时必须明确指出相应属性列名*/</span> </span><br><span class="line"><span class="comment">/*把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户*/</span>     </span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">INSERT</span> </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line">    <span class="keyword">TO</span> U5</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>REVOKE</p>
<ul>
<li><p>授予的权限可以由DBA或其他授权者用REVOKE语句收回</p>
</li>
<li><p>REVOKE语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]... </span><br><span class="line">   [<span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;]</span><br><span class="line">   <span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>级联删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用户U5对SC表的INSERT权限收回*/</span></span><br><span class="line">		<span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> </span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line">		<span class="keyword">FROM</span> U5 <span class="keyword">CASCADE</span> ;</span><br><span class="line"><span class="comment">/*将用户U5的INSERT权限收回的时候必须级联（CASCADE）收回 </span></span><br><span class="line"><span class="comment">系统只收回直接或间接从U5处获得的权限 */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库角色：被命名的一组与数据库操作相关的权限</p>
<ul>
<li>角色是权限的集合 </li>
<li>可以为一组具有相同权限的用户创建一个角色</li>
<li>简化授权的过程</li>
<li>类比：Windows操作系统中的用户组</li>
</ul>
</li>
</ol>
<h1 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h1><ol>
<li><p>数据库的完整性：数据的正确性和相容性</p>
</li>
<li><p>数据的完整性和安全性是两个不同概念</p>
<ul>
<li>数据的完整性<ul>
<li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
<li>防范对象：不合语义的、不正确的数据</li>
</ul>
</li>
<li>数据的安全性<ul>
<li>保护数据库防止恶意的破坏和非法的存取</li>
<li>防范对象：非法用户和非法操作</li>
</ul>
</li>
</ul>
</li>
<li><p>完整性约束的分类</p>
<ul>
<li><p>完整性约束条件中涉及的约束对象</p>
<ul>
<li>关系</li>
<li>元组</li>
<li>列</li>
</ul>
</li>
<li><p><strong>值约束和结构约束</strong><br>例：在向“学生成绩”关系中插入数据和更新数据时，需检查新的“学号”和“课程号”是否在“学生”关系和“课程”关系中已存在，否则不允许插入和更新。</p>
</li>
<li><p><strong>静态约束与动态约束</strong><br>例：动态约束的例子，在更新“学生”关系中的“年龄”字段时，新值必须大于旧值</p>
</li>
<li><p><strong>立即执行约束和延迟执行约束</strong><br>例：银行业务中，从账户A转移资金X到账户B，约束条件是总资金不变</p>
</li>
</ul>
</li>
<li><p>为维护数据库的完整性，DBMS必须：</p>
<ul>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>违约处理</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/" data-id="cknhe7bxf0074ows64vn588fw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/" class="article-date">
  <time datetime="2020-03-12T07:22:04.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/">《数据库系统概论》(王珊  萨师煊)复习笔记（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章  关系数据库标准语言SQL"></a>第三章  关系数据库标准语言SQL</h1><h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1 SQL概述"></a>1 SQL概述</h2><ol>
<li><p> QL(Structured Query Language)：结构化查询语言，是关系数据库的标准语言，SQL是一个通用的、功能极强的关系数据库语言</p>
</li>
<li><p><strong>特点</strong></p>
<p>（1）综合统一</p>
<ul>
<li><strong>集数据定义语言（DDL），数据操纵语言（DML），数据控制语（DCL）</strong>功能于一体。</li>
<li>可以独立完成数据库生命周期中的全部活动：<ul>
<li>定义关系模式，插入数据，建立数据库；</li>
<li>对数据库中的数据进行查询和更新；</li>
<li> 数据库重构和维护</li>
<li> 数据库安全性、完整性控制等</li>
</ul>
</li>
<li>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。</li>
<li>数据操作符统一</li>
</ul>
<p>（2）高度非过程化</p>
<ul>
<li>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径</li>
<li>SQL只要提出“做什么”，无须了解存取路径。</li>
<li>存取路径的选择以及SQL的操作过程由系统自动完成。</li>
</ul>
<p>（3）面向集合的操作方式</p>
<ul>
<li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li>
<li>SQL采用集合操作方式<ul>
<li>操作对象、查找结果可以是元组的集合</li>
<li>一次插入、删除、更新操作的对象可以是元组的集合</li>
</ul>
</li>
</ul>
<p>（4）多种使用方式</p>
<ul>
<li><strong>交互式SQL</strong><ul>
<li>一般DBMS都提供联机交互工具</li>
<li>用户可直接键入SQL命令对数据库进行操作</li>
<li>由DBMS来进行解释</li>
</ul>
</li>
<li><strong>嵌入式SQL</strong><ul>
<li>能将SQL语句嵌入到高级语言（宿主语言）</li>
<li>使应用程序充分利用SQL访问数据库的能力、宿主语言的过程处理能力</li>
<li>一般需要预编译，将嵌入的SQL语句转化为宿主语言编译器能处理的语句</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SQL的功能</strong></p>
<ul>
<li><p>数据定义（DDL）</p>
<ul>
<li>定义、删除、修改基本表（Base Table）</li>
<li>定义、删除视图（View）</li>
<li>定义、删除索引（Index）</li>
</ul>
</li>
<li><p>数据操纵（DML）</p>
<ul>
<li>数据查询</li>
<li>数据增、删、改</li>
</ul>
</li>
<li><p>数据控制（DCL）</p>
<ul>
<li>用户访问权限的授予、收回</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SQL数据库的体系结构</strong></p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/SQL%E4%B8%89%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.PNG"></p>
</li>
<li><p><strong>基本表</strong></p>
<ul>
<li>本身独立存在的表</li>
<li>SQL中一个关系就对应一个基本表</li>
<li>一个(或多个)基本表对应一个存储文件</li>
<li>一个表可以带若干索引</li>
</ul>
</li>
<li><p><strong>存储文件</strong></p>
<ul>
<li>逻辑结构组成了关系数据库的内模式</li>
<li>物理结构是任意的，对用户透明</li>
</ul>
</li>
<li><p><strong>视图</strong></p>
<ul>
<li>从一个或几个基本表导出的表</li>
<li>数据库中只存放视图的定义而不存放视图对应的数据</li>
<li>视图是一个虚表</li>
<li>用户可以在视图上再定义视图</li>
</ul>
</li>
</ol>
<h2 id="2-数据查询"><a href="#2-数据查询" class="headerlink" title="2 数据查询"></a>2 数据查询</h2><ol>
<li><p><strong>SQL查询表达式的基本结构</strong></p>
<p>select     属性名表<br>from      关系名表<br>where  (条件表达式)</p>
</li>
<li><p><strong>语句结构</strong></p>
<p><strong>SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] …</strong><br><strong>FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] …</strong><br><strong>[ WHERE &lt;条件表达式&gt; ]</strong><br><strong>[ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ]</strong><br><strong>[ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]；</strong></p>
</li>
<li><p><strong>单表查询</strong></p>
<p>示例：</p>
<ul>
<li>学生-课程模式 S-T :<br>学生表：Student(Sno,Sname,Ssex,Sage,Sdept)<br>课程表：Course(Cno,Cname,Cpno,Ccredit)<br>学生选课表：SC(Sno,Cno,Grade)</li>
</ul>
<p>（1） <strong>选择表中的若干列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno，Sname <span class="keyword">FROM</span> Student； </span><br><span class="line"><span class="keyword">SELECT</span>  * <span class="keyword">FROM</span> Student； </span><br><span class="line">//<span class="keyword">SELECT</span>子句的&lt;目标列表达式&gt;可以为：算术表达式、字符串、常量函数、列别名 </span><br><span class="line"><span class="keyword">SELECT</span> Sname，<span class="number">2009</span>-Sage <span class="keyword">FROM</span> Student；</span><br><span class="line"><span class="keyword">SELECT</span> Sname，<span class="keyword">LOWER</span>(Sdept)  <span class="keyword">FROM</span> Student；//小写字母表示所有系名</span><br><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">NAME</span>，<span class="keyword">LOWER</span>(Sdept)  DEPARTMENT <span class="keyword">FROM</span> Student；</span><br></pre></td></tr></table></figure>

<p>（2） <strong>选择表中的若干元组</strong></p>
<ul>
<li>消除取值重复的行，如果没有指定DISTINCT关键词，则缺省为ALL </li>
<li>指定DISTINCT关键词，去掉表中重复的行 </li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno   <span class="keyword">FROM</span> SC；//等价于：<span class="keyword">SELECT</span> <span class="keyword">ALL</span>  Sno  <span class="keyword">FROM</span> SC；</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno <span class="keyword">FROM</span> SC；</span><br></pre></td></tr></table></figure>

<ul>
<li>查询满足条件的元组</li>
<li><strong>常用的查询条件</strong></li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.PNG"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//查询计算机科学系全体学生的名单。</span><br><span class="line">    <span class="keyword">SELECT</span> Sname </span><br><span class="line">    <span class="keyword">FROM</span> Student</span><br><span class="line">    <span class="keyword">WHERE</span> Sdept=‘CS’；</span><br><span class="line"></span><br><span class="line">//查询年龄在<span class="number">20</span>~<span class="number">23</span>岁（包括<span class="number">20</span>岁和<span class="number">23</span>岁）之间的学生的姓名、系别和年龄</span><br><span class="line">    <span class="keyword">SELECT</span> Sname，Sdept，Sage </span><br><span class="line">    <span class="keyword">FROM</span> Student </span><br><span class="line">    <span class="keyword">WHERE</span> Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>； </span><br><span class="line">//查询信息系（<span class="keyword">IS</span>）、数学系（MA）和计算机科学系（CS）学生的姓名和性别。</span><br><span class="line">	<span class="keyword">SELECT</span> Sname，Ssex</span><br><span class="line">	<span class="keyword">FROM</span>  Student</span><br><span class="line">	<span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> ( <span class="string">&#x27;IS&#x27;</span>，<span class="string">&#x27;MA&#x27;</span>，<span class="string">&#x27;CS&#x27;</span> );</span><br><span class="line">	</span><br><span class="line">//匹配串为固定字符串</span><br><span class="line">//查询学号为200215121的学生的详细情况。</span><br><span class="line">     <span class="keyword">SELECT</span> *    </span><br><span class="line">     <span class="keyword">FROM</span>  Student  </span><br><span class="line">     <span class="keyword">WHERE</span>  Sno <span class="keyword">LIKE</span> <span class="string">&#x27;200215121&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">//匹配串为含通配符的字符串</span><br><span class="line">//查询所有姓刘学生的姓名、学号和性别。</span><br><span class="line">      <span class="keyword">SELECT</span> Sname，Sno，Ssex</span><br><span class="line">      <span class="keyword">FROM</span> Student</span><br><span class="line">      <span class="keyword">WHERE</span>  Sname <span class="keyword">LIKE</span> ‘刘%’；</span><br><span class="line"></span><br><span class="line">//查询以<span class="string">&quot;DB_&quot;</span>开头，且倒数第<span class="number">3</span>个字符为 i的课程的详细情况。</span><br><span class="line">      <span class="keyword">SELECT</span>  *</span><br><span class="line">      <span class="keyword">FROM</span>   Course</span><br><span class="line">      <span class="keyword">WHERE</span>  Cname <span class="keyword">LIKE</span>  <span class="string">&#x27;DB\_%i_ _&#x27;</span> ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line">      </span><br><span class="line">//查所有有成绩的学生学号和课程号。</span><br><span class="line">      <span class="keyword">SELECT</span> Sno，Cno</span><br><span class="line">      <span class="keyword">FROM</span>  SC</span><br><span class="line">      <span class="keyword">WHERE</span>  Grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>；</span><br></pre></td></tr></table></figure>

<p>（3）<strong>ORDER</strong> BY子句</p>
<ul>
<li>ORDER BY子句<ul>
<li>可以按一个或多个属性列排序</li>
<li>升序：ASC；  降序：DESC；缺省值为升序</li>
</ul>
</li>
<li>当排序列含空值时<ul>
<li>ASC：排序列为空值的元组最后显示</li>
<li>DESC：排序列为空值的元组最先显示 </li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。</span><br><span class="line">        <span class="keyword">SELECT</span>  *</span><br><span class="line">        <span class="keyword">FROM</span>  Student</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> Sdept，Sage <span class="keyword">DESC</span>； </span><br></pre></td></tr></table></figure>

<p>（4） <strong>聚集函数</strong></p>
<ul>
<li><p>计数</p>
<ul>
<li>COUNT（[ DISTINCT | ALL ] *）</li>
<li>COUNT（[ DISTINCT | ALL ] &lt;列名&gt;）</li>
</ul>
</li>
<li><p>计算总和</p>
<ul>
<li>SUM（[ DISTINCT | ALL ] &lt;列名&gt;）    </li>
</ul>
</li>
<li><p>计算平均值</p>
<ul>
<li>AVG（[ DISTINCT | ALL ] &lt;列名&gt;）</li>
</ul>
</li>
<li><p>最大最小值</p>
<ul>
<li>MAX（[ DISTINCT | ALL ] &lt;列名&gt;）</li>
<li>MIN（[ DISTINCT | ALL ] &lt;列名&gt;）</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询选修了课程的学生人数。</span><br><span class="line">     <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line">     <span class="keyword">FROM</span> SC；</span><br></pre></td></tr></table></figure>

<p>（5）<strong>GROUP</strong> BY子句</p>
<ul>
<li>细化聚集函数的作用对象</li>
<li>未对查询结果分组，聚集函数将作用于整个查询结果</li>
<li> 对查询结果分组后，聚集函数将分别作用于每个组 </li>
<li>作用对象是查询的中间结果表</li>
<li>按指定的一列或多列值分组，值相等的为一组</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询选修了3门以上课程的学生学号。</span><br><span class="line">     <span class="keyword">SELECT</span> Sno</span><br><span class="line">     <span class="keyword">FROM</span>  SC</span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line">     <span class="keyword">HAVING</span>  <span class="keyword">COUNT</span>(*) &gt;<span class="number">3</span>；   </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>HAVING</strong>短语与WHERE子句的区别：<br>作用对象不同<br>WHERE子句作用于基表或视图，从中选择满足条件的元组<br>HAVING短语作用于组，从中选择满足条件的组。 </li>
</ul>
</li>
<li><p><strong>集合查询</strong></p>
<p>并操作UNION<br>交操作INTERSECT<br>差操作EXCEPT</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  查询计算机科学系的学生及年龄不大于19岁的学生。</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> Student</span><br><span class="line">        <span class="keyword">WHERE</span> Sdept= <span class="string">&#x27;CS&#x27;</span></span><br><span class="line">        <span class="keyword">UNION</span></span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> Student</span><br><span class="line">        <span class="keyword">WHERE</span> Sage&lt;=<span class="number">19</span>；</span><br><span class="line"><span class="keyword">UNION</span>：将多个查询结果合并起来时，系统自动去掉重复元组。</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span>：将多个查询结果合并起来时，保留重复元组 </span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p><strong>连接查询</strong>：同时涉及多个表的查询</p>
<ul>
<li><p>连接条件或连接谓词：用来连接两个表的条件</p>
</li>
<li><p>一般格式：</p>
<ul>
<li>[&lt;表名1&gt;.]&lt;列名1&gt;  &lt;比较运算符&gt;  [&lt;表名2&gt;.]&lt;列名2&gt;</li>
<li>[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li>
</ul>
</li>
<li><p>连接字段：连接谓词中的列名称</p>
</li>
<li><p>连接条件中的各连接字段类型必须是可比的，但名字不必是相同的</p>
<ul>
<li><strong>等值连接</strong>：连接运算符为 =<br>查询每个学生及其选修课程的情况</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.*，SC.*</span><br><span class="line"><span class="keyword">FROM</span>     Student，SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno = SC.Sno；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自然连接</strong>：<br>查询每个学生及其选修课程的情况</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade</span><br><span class="line"><span class="keyword">FROM</span>     Student，SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno = SC.Sno；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自身连接</strong>：一个表与其自己进行连接<br>需要给表起别名以示区别<br>由于所有属性名都是同名属性，因此必须使用别名前缀</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：查询每一门课的间接先修课（即先修课的先修课）</span><br><span class="line">     <span class="keyword">SELECT</span>  FIRST.Cno，SECOND.Cpno</span><br><span class="line">     <span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>，Course  <span class="keyword">SECOND</span></span><br><span class="line">     <span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>外连接与普通连接的区别</strong><br>普通连接操作只输出满足连接条件的元组<br>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询每个学生及其选修课程的情况</span><br><span class="line">   <span class="keyword">SELECT</span> Student.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade</span><br><span class="line">    <span class="keyword">FROM</span>  Student  <span class="keyword">LEFT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> (Student.Sno=SC.Sno)； </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>复合条件连接</strong>：WHERE子句中含多个连接条件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询每个学生的学号、姓名、选修的课程名及成绩</span><br><span class="line">   <span class="keyword">SELECT</span> Student.Sno，Sname，Cname，Grade</span><br><span class="line">   <span class="keyword">FROM</span>    Student，SC，Course    <span class="comment">/*多表连接*/</span></span><br><span class="line">   <span class="keyword">WHERE</span> Student.Sno = SC.Sno </span><br><span class="line">                   <span class="keyword">and</span> SC.Cno = Course.Cno；</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p><strong>嵌套查询</strong></p>
<ul>
<li><p>一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
</li>
<li><p><strong>子查询的限制</strong></p>
<ul>
<li>不能使用ORDER BY子句</li>
<li>层层嵌套方式反映了 SQL语言的结构化</li>
<li>有些嵌套查询可以用连接运算替代     </li>
</ul>
</li>
<li><p> <strong>带有IN谓词的子查询</strong> </p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查询与“刘晨”在同一个系学习的学生。</span><br><span class="line">    <span class="keyword">SELECT</span> Sno，Sname，Sdept</span><br><span class="line">    <span class="keyword">FROM</span> Student</span><br><span class="line">   	<span class="keyword">WHERE</span> Sdept  <span class="keyword">IN</span></span><br><span class="line">                  (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                   <span class="keyword">FROM</span> Student</span><br><span class="line">                   <span class="keyword">WHERE</span> Sname= ‘ 刘晨 ’)；</span><br><span class="line">用自身连接完成查询要求</span><br><span class="line">      <span class="keyword">SELECT</span>  S1.Sno，S1.Sname，S1.Sdept</span><br><span class="line">      <span class="keyword">FROM</span>     Student S1，Student S2</span><br><span class="line">      <span class="keyword">WHERE</span>  S1.Sdept = S2.Sdept  <span class="keyword">AND</span></span><br><span class="line">                      S2.Sname = <span class="string">&#x27;刘晨&#x27;</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带有比较运算符的子查询</strong><ul>
<li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</li>
<li>与ANY或ALL谓词配合使用</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设一个学生只可能在一个系学习，并且必须属于一个系，</span><br><span class="line">     <span class="keyword">SELECT</span> Sno，Sname，Sdept</span><br><span class="line">     <span class="keyword">FROM</span>    Student</span><br><span class="line">	 <span class="keyword">WHERE</span> Sdept  =</span><br><span class="line">                   (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                    <span class="keyword">FROM</span>    Student</span><br><span class="line">                    <span class="keyword">WHERE</span> Sname= ‘刘晨’)；</span><br><span class="line">找出每个学生超过他选修课程平均成绩的课程号。                      <span class="keyword">SELECT</span> Sno， Cno</span><br><span class="line">	 <span class="keyword">FROM</span>  SC  x</span><br><span class="line">	 <span class="keyword">WHERE</span> Grade &gt;=( <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade) </span><br><span class="line">		             <span class="keyword">FROM</span>  SC y</span><br><span class="line">                     <span class="keyword">WHERE</span> y.Sno=x.Sno ) ;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>带有ANY（SOME）或ALL谓词的子查询</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查询其他系中比计算机科学某一学生年龄小的学生姓名和年龄</span><br><span class="line">     <span class="keyword">SELECT</span> Sname，Sage</span><br><span class="line">	 <span class="keyword">FROM</span>    Student</span><br><span class="line">	 <span class="keyword">WHERE</span> Sage &lt; <span class="keyword">ANY</span> (<span class="keyword">SELECT</span>  Sage</span><br><span class="line">                       <span class="keyword">FROM</span>    Student</span><br><span class="line">                       <span class="keyword">WHERE</span> Sdept= <span class="string">&#x27; CS &#x27;</span>)</span><br><span class="line">           <span class="keyword">AND</span> Sdept &lt;&gt; ‘CS <span class="string">&#x27; ;  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>带有<strong>EXISTS</strong>谓词的子查询<ul>
<li>EXISTS谓词<ul>
<li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑值“true”或逻辑假值“false”。</li>
<li>若内层查询结果非空，则外层的WHERE子句返回真值</li>
<li>若内层查询结果为空，则外层的WHERE子句返回假值</li>
<li>由EXISTS引出的子查询，其目标列表达式通常都用* ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查询没有选修1号课程的学生姓名。</span><br><span class="line">     <span class="keyword">SELECT</span> Sna me</span><br><span class="line">     <span class="keyword">FROM</span> Student</span><br><span class="line">     <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">             (<span class="keyword">SELECT</span> *</span><br><span class="line">              <span class="keyword">FROM</span> SC</span><br><span class="line">              <span class="keyword">WHERE</span> Sno = Student.Sno <span class="keyword">AND</span> Cno=<span class="string">&#x27;1&#x27;</span>)；</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-数据定义"><a href="#3-数据定义" class="headerlink" title="3 数据定义"></a>3 数据定义</h2><ul>
<li>SQL的数据定义功能: 模式定义、表定义、视图和索引的定义</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.PNG"></p>
<ul>
<li><p><strong>模式</strong></p>
<ul>
<li>定义模式实际上定义了一个命名空间，在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</li>
<li>删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE | RESTRICT&gt;<ul>
<li>CASCADE(级联)<pre><code>删除模式的同时把该模式中所有的数据库对象全部删除</code></pre>
</li>
<li>RESTRICT(限制)<br> 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。当该模式中没有任何下属的对象时才能执行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基本表</strong></p>
<ul>
<li><strong>定义基本表</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">建立“学生”表Student，学号是主码，姓名取值唯一。</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student          </span><br><span class="line">	      (Sno   <span class="built_in">CHAR</span>(<span class="number">9</span>) PRIMARY <span class="keyword">KEY</span>， </span><br><span class="line">            Sname  <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>，<span class="comment">/* Sname取唯一值*/</span></span><br><span class="line">            Ssex    <span class="built_in">CHAR</span>(<span class="number">2</span>)，</span><br><span class="line">            Sage   <span class="built_in">SMALLINT</span>，</span><br><span class="line">            Sdept  <span class="built_in">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">           )； </span><br><span class="line">建立一个“课程”表Course</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  Course</span><br><span class="line">           ( Cno    <span class="built_in">CHAR</span>(<span class="number">4</span>) PRIMARY <span class="keyword">KEY</span>，</span><br><span class="line">             Cname  <span class="built_in">CHAR</span>(<span class="number">40</span>)，            </span><br><span class="line">             Cpno    <span class="built_in">CHAR</span>(<span class="number">4</span>) ，               	 </span><br><span class="line">             Ccredit  <span class="built_in">SMALLINT</span>，</span><br><span class="line">             <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cpno) <span class="keyword">REFERENCES</span> Course(Cno) </span><br><span class="line">            ); </span><br><span class="line">建立一个“学生选课”表SC</span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  SC</span><br><span class="line">       	(Sno  <span class="built_in">CHAR</span>(<span class="number">9</span>)， </span><br><span class="line">       	Cno  <span class="built_in">CHAR</span>(<span class="number">4</span>)，  </span><br><span class="line">       	Grade    <span class="built_in">SMALLINT</span>，</span><br><span class="line">      <span class="comment">/* 主码由两个属性构成，必须作为表级完整性进行定义*/</span></span><br><span class="line">       	PRIMARY <span class="keyword">KEY</span> (Sno，Cno)，</span><br><span class="line">      <span class="comment">/* 表级完整性约束条件，Sno是外码，被参照表是Student */</span></span><br><span class="line">       	<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Sno) <span class="keyword">REFERENCES</span> Student(Sno)，</span><br><span class="line">      <span class="comment">/* 表级完整性约束条件， Cno是外码，被参照表是Course*/</span></span><br><span class="line">       	<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">		); </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改基本表</strong>：不论基本表中原来是否已有数据，新增加的列一律为空值。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*向Student表增加“入学时间”列，其数据类型为日期型。*/</span></span><br><span class="line">     <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ADD</span> S_entrance <span class="built_in">DATE</span>；</span><br><span class="line"><span class="comment">/*将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。*/</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> Sage <span class="built_in">INT</span>；</span><br><span class="line"><span class="comment">/*增加课程名称必须取唯一值的约束条件。*/</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Course <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(Cname); </span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>删除基本表</strong>：DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］；</p>
<ul>
<li>RESTRICT：删除表是有限制的。<br>欲删除的基本表不能被其他表的约束所引用。如果存在依赖该表的对象，则此表不能被删除</li>
<li>CASCADE：删除该表没有限制。<br>在删除基本表的同时，相关的依赖对象一起删除 </li>
</ul>
</li>
<li><p><strong>索引</strong></p>
<ul>
<li>建立索引的目的：加快查询速度</li>
<li>谁可以建立索引<br>DBA 或 表的属主（即建立表的人）<br>DBMS一般会自动建立以下列上的索引<pre><code>  PRIMARY  KEY
  UNIQUE</code></pre>
</li>
<li>谁维护索引<pre><code> DBMS自动完成 </code></pre>
</li>
<li>使用索引<pre><code> DBMS自动选择是否使用索引以及使用哪些索引</code></pre>
</li>
<li>RDBMS中索引一般采用B+树、HASH索引来实现<ul>
<li>B+树索引具有动态平衡的优点 ，HASH索引具有查找速度快的特点，采用B+树，还是HASH索引 则由具体的RDBMS来决定</li>
<li>索引是关系数据库的内部实现技术，属于内模式的范畴 </li>
<li>CREATE INDEX语句定义索引时，可以定义索引是唯一索引、非唯一索引或聚簇索引 </li>
<li>在最经常查询的列上建立聚簇索引以提高查询效率 ，一个基本表上最多只能建立一个聚簇索引 ，经常更新的列不宜建立聚簇索引 </li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在Student表的Sname（姓名）列上建立一个聚簇索引*/</span></span><br><span class="line"><span class="keyword">CREATE</span> CLUSTER <span class="keyword">INDEX</span> Stusname <span class="keyword">ON</span>  Student(Sname)；</span><br><span class="line"><span class="comment">/* SC表按学号升序和课程号降序建唯一索引*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span>  SCno <span class="keyword">ON</span> SC(Sno <span class="keyword">ASC</span>，Cno <span class="keyword">DESC</span>)；</span><br></pre></td></tr></table></figure>

<ul>
<li>删除索引时，系统会从数据字典中删去有关该索引的描述。</li>
</ul>
</li>
</ul>
<h2 id="4-数据更新"><a href="#4-数据更新" class="headerlink" title="4 数据更新"></a>4 数据更新</h2><ol>
<li><p><strong>插入数据</strong></p>
</li>
<li><p><strong>修改数据</strong></p>
<ul>
<li><strong>语句格式</strong><br>   UPDATE  &lt;表名&gt;<pre><code>SET  &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…
[WHERE &lt;条件&gt;]；</code></pre>
</li>
<li><strong>功能</strong><br>修改指定表中满足WHERE子句条件的元组的指定列值</li>
</ul>
</li>
<li><p><strong>删除数据</strong></p>
<p><strong>语句格式</strong></p>
<pre><code>   DELETE
   FROM     &lt;表名&gt;
   [WHERE &lt;条件&gt;]；</code></pre>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入一条选课记录( &#x27;200215128&#x27;，&#x27;1 &#x27;)。*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC(Sno，Cno) <span class="keyword">VALUES</span> (‘ <span class="number">200215128</span> ’，‘<span class="number">1</span><span class="string">&#x27;); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*将计算机科学系全体学生的成绩置零。*/</span></span><br><span class="line"><span class="string">       UPDATE SC</span></span><br><span class="line"><span class="string">        SET  Grade=0</span></span><br><span class="line"><span class="string">        WHERE  &#x27;</span>CS<span class="string">&#x27;=</span></span><br><span class="line"><span class="string">                (SELETE Sdept</span></span><br><span class="line"><span class="string">                 FROM  Student</span></span><br><span class="line"><span class="string">                 WHERE  Student.Sno = SC.Sno)；</span></span><br><span class="line"><span class="string">/*删除学号为200215128的学生记录。*/</span></span><br><span class="line"><span class="string"> DELETE FROM Student WHERE Sno= ‘200215128 &#x27;</span>；</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 视图"></a>5 视图</h2><ol>
<li><p><strong>视图的特点</strong></p>
<ul>
<li>虚表，是从一个或几个基本表（或视图）导出的表</li>
<li>只存放视图的定义，不存放视图对应的数据</li>
<li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li>
</ul>
</li>
<li><p><strong>基于视图的操作</strong></p>
<ul>
<li>查询</li>
<li> 删除</li>
<li> 受限更新</li>
<li> 定 义基于该视图的新视图。</li>
</ul>
</li>
<li><p><strong>定义视图</strong></p>
<ul>
<li><strong>语句格式</strong><pre><code>   CREATE  VIEW  &lt;视图名&gt;  [(&lt;列名&gt;  [，&lt;列名&gt;]…)]
   AS  &lt;子查询&gt;
   [WITH  CHECK  OPTION]；</code></pre>
</li>
<li>成视图的属性列组名：全部省略或全部指定</li>
<li>子查询不允许含有ORDER B‘’‘Y子句和DISTINCT短语</li>
<li>RDBMS执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句。</li>
<li>在对视图查询时，按视图的定义从基本表中将数据查出。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生。*/</span></span><br><span class="line">        <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line">        <span class="keyword">AS</span> </span><br><span class="line">        <span class="keyword">SELECT</span> Sno，Sname，Sage</span><br><span class="line">        <span class="keyword">FROM</span>  Student</span><br><span class="line">        <span class="keyword">WHERE</span>  Sdept= <span class="string">&#x27;IS&#x27;</span></span><br><span class="line">        <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">带WITH CHECK OPTION选项时对IS_Student视图的更新操作：</span></span><br><span class="line"><span class="comment">修改操作：自动加上Sdept= &#x27;IS&#x27;的条件</span></span><br><span class="line"><span class="comment">删除操作：自动加上Sdept= &#x27;IS&#x27;的条件</span></span><br><span class="line"><span class="comment">插入操作：自动检查Sdept属性值是否为&#x27;IS&#x27; </span></span><br><span class="line"><span class="comment">如果不是，则拒绝该插入操作</span></span><br><span class="line"><span class="comment">如果没有提供Sdept属性值，则自动定义Sdept为&#x27;IS&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基于多个基表的视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立信息系选修了1号课程的学生视图。*/</span></span><br><span class="line">	    <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno，Sname，Grade)</span><br><span class="line">        <span class="keyword">AS</span> </span><br><span class="line">        <span class="keyword">SELECT</span> Student.Sno，Sname，Grade</span><br><span class="line">        <span class="keyword">FROM</span>  Student，SC</span><br><span class="line">        <span class="keyword">WHERE</span>  Sdept= <span class="string">&#x27;IS&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">                       Student.Sno=SC.Sno <span class="keyword">AND</span></span><br><span class="line">                       SC.Cno= <span class="string">&#x27;1&#x27;</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基于视图的视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 建立信息系选修了1号课程且成绩在90分以上的学生的视图。*/</span></span><br><span class="line">        <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line">        <span class="keyword">AS</span></span><br><span class="line">        <span class="keyword">SELECT</span> Sno，Sname，Grade</span><br><span class="line">        <span class="keyword">FROM</span>  IS_S1</span><br><span class="line">        <span class="keyword">WHERE</span>  Grade&gt;=<span class="number">90</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带表达式的视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个反映学生出生年份的视图。*/</span></span><br><span class="line">        <span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> BT_S(Sno，Sname，Sbirth)</span><br><span class="line">        <span class="keyword">AS</span> </span><br><span class="line">        <span class="keyword">SELECT</span> Sno，Sname，<span class="number">2007</span>-Sage</span><br><span class="line">        <span class="keyword">FROM</span>  Student；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分组视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将学生的学号及他的平均成绩定义为一个视图,假设SC表中“成绩”列Grade为数字型*/</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line">	<span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>不指定属性列</strong>:</p>
<p>缺点：修改基表Student的结构后，Student表与F_Student视图的映象关系被破坏，导致该视图不能正确工作。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> F_Student(F_Sno，<span class="keyword">name</span>，sex，age，dept)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Ssex=‘女’；</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除视图</strong></p>
<ul>
<li>语句的格式：DROP  VIEW  &lt;视图名&gt;；</li>
<li>该语句从数据字典中删除指定的视图定义</li>
<li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除 </li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除 </li>
</ul>
</li>
<li><p><strong>查询视图</strong></p>
<ul>
<li>用户角度：查询视图与查询基本表相同</li>
<li>RDBMS实现视图查询的方法<ul>
<li>视图消解法（View Resolution）</li>
<li>进行有效性检查</li>
<li>转换成等价的对基本表的查询</li>
<li>执行修正后的查询</li>
<li>有些情况下，视图消解法不能生成正确查询。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>更新视图</strong></p>
<ul>
<li>更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新</li>
</ul>
</li>
<li><p><strong>视图的作用</strong></p>
<ul>
<li>视图能够简化用户的操作<br>视图机制使用户可以将注意力集中在他所关心的数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使用户眼中的数据库结构简单、清晰，并且可以简化用户的数据查询操作。</li>
<li>视图使用户能以多种角度看待同一数据<br>视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户使用同一个数据库时，这种灵活性是非常重要的。</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性 </li>
<li>视图能够对机密数据提供安全保护<br>有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应看到这些数据的用户视图上，这样就由视图的机制自动提供了对机密数据的安全保护功能。 </li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/" data-id="cknhe7byk008rows6fe5z2dwz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/" class="article-date">
  <time datetime="2020-03-11T13:02:56.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/">《数据库系统概论》(王珊  萨师煊)复习笔记（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章  关系数据库"></a>第二章  关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1 关系数据结构及形式化定义"></a>1 关系数据结构及形式化定义</h2><ol>
<li><p>二维表：逻辑结构，从用户角度，关系模型中数据的逻辑结构是一张二维表</p>
</li>
<li><p>建立在集合代数的基础上</p>
</li>
<li><p>域：一组具有相同数据类型的值的集合</p>
</li>
<li><p><strong>笛卡尔积</strong>：给定一组域D1，D2，…，Dn，这些域中可以有相同的。</p>
<p>D1×D2×…×Dn ＝｛（d1，d2，…，dn）｜di属于Di，i＝1，2，…，n｝</p>
<p><strong>元组</strong>：笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组（n-tuple）或简称元组(Tuple)<br>(张三，计算机专业，男)等都是元组 ，通常用t表示<br><strong>分量</strong>：笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个分量。张三，计算机专业，男等都是分量<br><strong>基数</strong>：若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1，2，…，n），则D1×D2×…×Dn的基数M为：M = M1<em>M2</em>…..*Mn</p>
<p><strong>表示方法</strong>：笛卡尔积可表示为一个二维表，表中的每行对应一个元组，表中的每列对应一个域</p>
<p>示例：D1为教师集合（T）= {t1，t2}， D2为学生集合（S）= {s1，s2 ，s3}，D3为课程集合（C）= {c1，c2}<br>则D1×D2×D3是个三元组集合，元组个数为2×3×2，是所有可能的（教师，学生，课程）元组集合</p>
<p><strong>子集</strong></p>
</li>
</ol>
<ul>
<li>关系<br>   D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，表示为R（D1，D2，…，Dn）<br>R：关系名<br>   n：关系的目或度（Degree）<ul>
<li>元组<br>关系中的每个元素是关系中的元组，通常用t表示。</li>
<li>单元关系与二元关系<br>当n=1时，称该关系为单元关系（Unary relation）或一元关系<br>当n=2时，称该关系为二元关系（Binary relation）</li>
</ul>
</li>
<li>关系的表示<br>   关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域<ul>
<li>属性<br>关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。n目关系必有n个属性</li>
</ul>
</li>
</ul>
<ol start="5">
<li><p>候选码（Candidate key）：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。简单的情况：候选码只包含一个属性</p>
</li>
<li><p>全码（All-key）：最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码</p>
</li>
<li><p>主码：若一个关系有多个候选码，则选定其中一个为主码（Primary key）</p>
</li>
<li><p>主属性：候选码的诸属性称为主属性（Prime attribute）<br>不包含在任何侯选码中的属性称为非主属性（ Non-Prime attribute）或非码属性（Non-key attribute）</p>
</li>
<li><p>三类关系<br>基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示<br>查询表：查询结果对应的表<br>视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</p>
</li>
<li><p>关系模式：是型，是对关系的描述，是静态的、稳定的</p>
<ul>
<li>是元素集合的结构</li>
<li>元组语义以及完整性约束条件</li>
<li>属性间的数据依赖关系集合</li>
</ul>
<p>通常简记为R (U)    或    R (A1，A2，…，An)    R: 关系名      A1，A2，…，An  : 属性名</p>
</li>
<li><p>关系数据库<br>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p>
</li>
</ol>
<ul>
<li>型：关系数据库模式，包括若干域的定义；在这些域上定义的若干关系模式。</li>
<li>值：关系模式在某一时刻对应的关系的集合，简称为关系数据库</li>
</ul>
<h2 id="2-关系操作"><a href="#2-关系操作" class="headerlink" title="2 关系操作"></a>2 关系操作</h2><ol>
<li>常用的关系操作<ul>
<li>查询：选择、投影、连接、除、并、交、差</li>
<li>数据更新：插入、删除、修改，查询的表达能力是其中最主要的部分</li>
<li><strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong></li>
</ul>
</li>
<li>操作特点：<ul>
<li>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</li>
<li>高度非过程化：只要指出“做什么”，不需要描述“怎么做”</li>
</ul>
</li>
</ol>
<h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3 关系代数"></a>3 关系代数</h2><ol>
<li>关系数据库语言分类<ul>
<li><strong>关系代数语言</strong>：用对关系的运算来表达查询要求。代表：ISBL</li>
<li><strong>关系演算语言</strong>：用谓词来表达查询要求<br>元组关系演算语言：谓词变元的基本对象是元组变量。代表：APLHA, QUEL<br>域关系演算语言：谓词变元的基本对象是域变量。代表：QBE</li>
<li><strong>关系代数和关系演算是相互等价的</strong></li>
<li>具有关系代数和关系演算<strong>双重特点</strong>的语言。代表：SQL（Structured Query Language） </li>
</ul>
</li>
<li>定义：关系数据库的一种抽象的查询语言，用对关系的运算来表达查询。</li>
<li>要素：运算对象（关系）、关系运算符</li>
<li>关系代数运算符</li>
</ol>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6.PNG"></p>
<ol start="5">
<li><p>交</p>
<ul>
<li><p>R和S：具有相同的目n；相应的属性取自同一个域</p>
</li>
<li><p>R∩S：仍为n目关系，由既属于R又属于S的元组组成</p>
<p>R∩S = { t|t 属于 R ∧ t 属于S }</p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E4%BA%A4%E9%9B%86%E4%B8%BE%E4%BE%8B.PNG"></p>
</li>
<li><p>差</p>
<ul>
<li><p>R和S：具有相同的目n，相应的属性取自同一个域</p>
</li>
<li><p>R - S ：仍为n目关系，由属于R而不属于S的所有元组组成     </p>
<p>R -S = { t|t属于R ∧ t属于S }  </p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%B7%AE%E9%9B%86.PNG"></p>
</li>
</ul>
</li>
<li><p>并</p>
<ul>
<li><p>R和S:具有相同的目n（即两个关系都有n个属性），相应的属性取自同一个域</p>
</li>
<li><p>R∪S ：仍为n目关系，由属于R或属于S的元组组成   R∪S = { t|t 属于 R ∨ t 属于S }</p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%B9%B6%E9%9B%86.PNG"></p>
</li>
</ul>
</li>
<li><p>笛卡尔积</p>
<ul>
<li>严格地讲应该是广义的笛卡尔积（Extended Cartesian Product）<br>R: n目关系，k1个元组<br>S: m目关系，k2个元组</li>
<li>R×S<br>列：（n+m）列元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组<br>行：k1×k2个元组</li>
</ul>
</li>
</ol>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/笛卡尔积.PNG" style="zoom:80%;" />

<ol start="5">
<li><p>选择</p>
<ul>
<li><p>在关系R中选择满足给定条件的元组   F(R)={t | t 属于 R ^F(t) = ‘真’}</p>
<p>F是选择的条件， F(t)要么为真，要么为假。F的形式：由逻辑运算符连接关系表达式而成</p>
</li>
</ul>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/选择运算.PNG" style="zoom:80%;" />
</li>
<li><p>投影</p>
<p>从关系R中取若干列组成新的关系（从列的角度），投影的结果中要去掉相同的行</p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/投影.PNG" style="zoom:80%;" />
</li>
<li><p>连接</p>
<p>连接操作是从两个关系的广义笛卡尔积中选择属性间满足一定条件的元组。通常写为：</p>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%BF%9E%E6%8E%A5%E5%AE%9A%E4%B9%89.PNG"></p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/连接.PNG" style="zoom:80%;" />
</li>
<li><p>等值连接和自然连接</p>
<p>等值连接：从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组</p>
<p>自然连接：若R和S具有相同的属性组（来自相同的域，表示相同的含义），且连接的运算符θ为“=”，在连接的结果中去掉重复的属性组</p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/等值自然连接.PNG" style="zoom:80%;" />
</li>
<li><p>外连接<br>如果把舍弃的元组也保存在结果关系中，而在其他属性上填空值(Null)，这种连接就叫做外连接。</p>
</li>
<li><p>左外连接<br>如果只把左边关系R中要舍弃的元组保留就叫做左外连接。</p>
</li>
<li><p>右外连接<br>如果只把右边关系S中要舍弃的元组保留就叫做右外连接。</p>
</li>
<li><p>象集</p>
<p>关系R(X , Z)，X、 Z是属性组，x是X上的取值，定义x在R中的象集为从R中选出在X上取值为x的元组，去掉X上的分量，只留Z上的分量    Zx = { t[Z] | t属于R 且 t[X]= x }</p>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/象集.PNG" style="zoom:80%;" />
</li>
<li><p>除</p>
<ul>
<li>给定关系R（X，Y）和S（Y，Z），其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的值域。</li>
<li>R与S的除运算得到一个新的关系P（X），P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。</li>
</ul>
<img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/除.PNG" style="zoom:80%;" />

</li>
</ol>
<h2 id="4-关系的完整性"><a href="#4-关系的完整性" class="headerlink" title="4 关系的完整性"></a>4 关系的完整性</h2><ol>
<li>实体完整性和参照完整性：关系模型必须满足的完整性约束条件，称为关系的两个不变性，应该由关系系统自动支持。</li>
<li>用户定义的完整性： 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 </li>
<li>实体完整性：若属性A是基本关系R的主属性，则属性A不能取空值</li>
<li>外码<ul>
<li>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码</li>
<li>基本关系R称为参照关系（Referencing  Relation）</li>
<li>基本关系S称为被参照关系（Referenced Relation）或目标关系（Target Relation）</li>
<li>例：学生关系的“专业号”与专业关系的主码“专业号”相对应<br>“专业号”属性是学生关系的外码<br>专业关系是被参照关系，学生关系为参照关系</li>
<li>关系R和S不一定是不同的关系</li>
<li>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li>
<li>外码并不一定要与相应的主码同名，当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别 </li>
</ul>
</li>
<li>参照完整性<ul>
<li>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元组的主码值</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/" data-id="cknhe7bxc006yows693kt3xj8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库复习笔记一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" class="article-date">
  <time datetime="2020-03-11T02:30:58.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">《数据库系统概论》(王珊  萨师煊)复习笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-数据库技术发展"><a href="#1-数据库技术发展" class="headerlink" title="1 数据库技术发展"></a>1 数据库技术发展</h2><ul>
<li>层次数据库技术：Rockwell公司与IBM公司合作研制了基于层次模型的数据管理系统IMS</li>
<li>网状数据库技术：通用电气公司的Charles Bachman主持设计与实现了网状模型的数据库管理系统IDS；CODASYL下属的数据库任务组DBTG提出的网状数据库模型以及数据定义和数据操纵语言即DDL和DML的规范说明，推出了DBTG报告；</li>
<li>关系数据库技术：IBM公司San Jose实验室的研究员Edgar F.Codd提出了关系数据模型</li>
<li>新一代数据库技术<ol>
<li>面向对象数据库</li>
<li>XML数据库</li>
<li>网络数据库、嵌入式移动数据库、多媒体数据库、知识数据库、模糊数据库……</li>
</ol>
</li>
</ul>
<h2 id="2-数据库系统概述"><a href="#2-数据库系统概述" class="headerlink" title="2 数据库系统概述"></a>2 数据库系统概述</h2><h3 id="2-1-四个基本概念"><a href="#2-1-四个基本概念" class="headerlink" title="2.1 四个基本概念"></a>2.1 四个基本概念</h3><ul>
<li><p><strong>数据(Data)</strong></p>
<ol>
<li><p>数据库中存储的基本对象，描述事物的符号记录</p>
</li>
<li><p>数据的种类</p>
<p>侠义：数字</p>
<p>广义：文字、图形、图象、声音</p>
</li>
<li><p>数据与其语义不可分</p>
<p>例如：93是一个数据，语义可以是学生某门课的成绩</p>
</li>
<li><p>记录是计算机中表示和存储数据的一种格式，是有结构的数据</p>
</li>
</ol>
</li>
<li><p><strong>数据库(DB)</strong></p>
<p>​        长期储存在计算机内，有组织的、可共享的大量数据的集合</p>
</li>
<li><p><strong>数据库管理系统(DBMS)</strong></p>
<ol>
<li><p>位于用户和操作系统之间的一层数据管理软件，是基础软件，一个大型复杂的软件系统。科学的组织和存储数据、高效的获取和维护数据。</p>
</li>
<li><p>主要功能</p>
<ul>
<li>数据定义功能</li>
</ul>
<p>​         提供数据定义语言(DDL)，及其翻译处理程序<br>​         定义数据库中的数据对象</p>
<ul>
<li><p>数据操纵功能</p>
<p>  提供数据操纵语言(DML)，及其编译程序<br>​  操纵数据实现对数据库的基本操作(查询、插入、删除和修改)</p>
</li>
<li><p>数据组织、存储和管理<br>​分类组织、存储和管理各种数据；  确定组织数据的文件结构和存取；实现数据之间的联系；提供多种存取方法提高存取效率</p>
</li>
<li><p>数据库的运行管理</p>
<p>保证数据的安全性、完整性； 多用户对数据的并发使用； 发生故障后的系统恢复</p>
</li>
<li><p>数据库的建立和维护功能(实用程序)</p>
<p> 数据库数据批量装载； 数据库转储；介质故障恢复； 数据库的重组织；性能监视等</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>数据库系统(DBS)</strong></p>
<p>在计算机系统中引入数据库后的系统构成，包括数据库、数据库管理系统、应用系统、数据库管理员</p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.PNG"></p>
<h3 id="2-2-数据管理技术的产生和发展"><a href="#2-2-数据管理技术的产生和发展" class="headerlink" title="2.2 数据管理技术的产生和发展"></a>2.2 数据管理技术的产生和发展</h3><ul>
<li><p>数据管理：对数据进行分类、组织、编码、存储、检索和维护</p>
</li>
<li><p><strong>发展</strong></p>
<ol>
<li><p>人工管理阶段：数据不保存；应用程序管理数据；数据不共享，冗余度极大；数据不具有独立性</p>
</li>
<li><p>文件系统阶段：</p>
<p>优点： 数据可长期保存；应用程序管理数据 ；文件系统管理数据<br>缺点：数据共享性差、冗余度大；数据独立性差</p>
</li>
<li><p>数据库系统阶段</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-3-数据库系统的特点"><a href="#2-3-数据库系统的特点" class="headerlink" title="2.3 数据库系统的特点"></a>2.3 数据库系统的特点</h3><ul>
<li><p>数据结构化</p>
<p>文件系统：每个文件内部是有结构的，但是记录之间没有联系</p>
<p>关系数据库：不仅数据内部结构化，整体也是结构化的，数据之间具有联系</p>
</li>
<li><p>数据的共享性高，冗余度低，易扩充</p>
</li>
<li><p>数据独立性高</p>
<ol>
<li><p>物理独立性</p>
<p>指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</p>
</li>
<li><p>逻辑独立性<br>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</p>
</li>
<li><p>数据独立性是由DBMS的二级映像功能来保证的</p>
</li>
</ol>
</li>
<li><p>数据由DBMS统一管理和控制</p>
<ol>
<li><p>数据的安全性（Security）保护<br>保护数据，以防止不合法的使用造成的数据的泄密和破坏。</p>
</li>
<li><p>数据的完整性（Integrity）检查<br>将数据控制在有效的范围内，或保证数据之间满足一定的关系。</p>
</li>
<li><p>并发（Concurrency）控制<br>对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p>
</li>
<li><p>数据库恢复（Recovery）</p>
<p>将数据库从错误状态恢复到某一已知的正确状态。</p>
</li>
</ol>
</li>
</ul>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3 数据模型"></a>3 数据模型</h2><h3 id="3-1-两大数据模型"><a href="#3-1-两大数据模型" class="headerlink" title="3.1 两大数据模型"></a>3.1 两大数据模型</h3><ul>
<li>在数据库中用数据模型这个工具来来<strong>抽象、表示和处理</strong>现实世界中的事物。通俗地讲数据模型就是现实世界的模拟。</li>
<li>数据模型应满足三方面要求：能比较真实地模拟现实世界，容易为人所理解，便于在计算机上实现</li>
<li>分类<ol>
<li>概念模型（信息模型）：它是按<strong>用户</strong>的观点来对数据和信息建模，用于数据库设计。 </li>
<li>逻辑模型和物理模型：按<strong>计算机系统</strong>的观点对数据建模，用于DBMS的实现。<ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。</li>
<li>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E5%AF%B9%E5%AE%A2%E8%A7%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B.PNG"></p>
<h3 id="3-2-数据模型的组成要素"><a href="#3-2-数据模型的组成要素" class="headerlink" title="3.2 数据模型的组成要素"></a>3.2 数据模型的组成要素</h3><ul>
<li><strong>数据结构</strong></li>
<li><strong>数据操作</strong></li>
<li><strong>完整性约束条件</strong></li>
</ul>
<h3 id="3-3-概念模型"><a href="#3-3-概念模型" class="headerlink" title="3.3 概念模型"></a>3.3 概念模型</h3><ul>
<li>信息世界的基本概念<ol>
<li>实体（Entity）：客观存在并可相互区别的事物称为实体，可以是具体的人、事、物或抽象的概念。</li>
<li>属性（Attribute）：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。  </li>
<li>码（Key）：唯一标识实体的属性集称为码。</li>
<li>域（Domain）：属性的取值范围称为该属性的域。 </li>
<li>实体型（Entity Type）：用<strong>实体名及其属性名集合</strong>来抽象和刻画<strong>同类实体</strong>称为实体型。例如：学生（学号、姓名、性别）</li>
<li>实体集（Entity Set）：同一类型实体的集合称为实体集</li>
<li>联系（Relationship）：现实世界中事物内部以及事物之间的联系在信息世界中反映为<strong>实体内部的联系和实体之间</strong>的联系。<ul>
<li>实体内部的联系通常是指组成实体的各属性之间的联系</li>
<li>实体之间的联系通常是指不同实体集之间的联系</li>
<li>一对一联系（1:1）、一对多联系（1:n）、多对多联系（m:n）</li>
</ul>
</li>
</ol>
</li>
<li>实体 — 联系方法（E-R方法、E-R模型）<ol>
<li>实体型：用矩形表示，矩形框内写实体名</li>
<li>属性：用椭圆表示，并用无向边将其与相应的实体连接起来</li>
<li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）</li>
<li>联系的属性：联系本身也是一种实体型，也   可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 </li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E8%81%94%E7%B3%BB%E5%B1%9E%E6%80%A7%E5%9B%BE.PNG"></p>
<h3 id="3-4-最常用的数据模型"><a href="#3-4-最常用的数据模型" class="headerlink" title="3.4 最常用的数据模型"></a>3.4 最常用的数据模型</h3><ul>
<li><p>层次模型：用<strong>树形结构</strong>来表示各类实体以及实体间的联系</p>
</li>
<li><p>网状模型：采用<strong>网状模型</strong>作为数据的组织方式 </p>
</li>
<li><p>关系模型：采用<strong>关系模型</strong>作为数据的组织方式</p>
<ol>
<li><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年龄</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>张三</td>
<td>16</td>
<td>男</td>
</tr>
<tr>
<td>0002</td>
<td>李四</td>
<td>18</td>
<td>男</td>
</tr>
</tbody></table>
</li>
<li><p>数据结构</p>
<ul>
<li>关系：一个关系对应通常说的一张表</li>
<li>元组（Tuple）：表中的一行即为一个元组</li>
<li>属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性</li>
<li>主码（Key）：表中的某个属性组，它可以唯一确定一个元组。</li>
</ul>
</li>
<li><p>域（Domain）：属性的取值范围。</p>
<ul>
<li>分量：元组中的一个属性值。</li>
<li>关系模式：对关系的描述，关系名（属性1，属性2，…，属性n）</li>
</ul>
</li>
<li><p><strong>关系的完整性约束条件</strong></p>
<ul>
<li><strong>实体完整性</strong></li>
<li><strong>参照完整性</strong></li>
<li><strong>用户定义的完整性</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4-数据库系统结构"><a href="#4-数据库系统结构" class="headerlink" title="4 数据库系统结构"></a>4 数据库系统结构</h2><h3 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h3><ul>
<li><p>从最终用户角度：</p>
<ol>
<li><p>单用户结构</p>
<p>整个数据库系统(应用程序、DBMS、数据)装在一台计算机上，为一个用户独占，不同机器之间不能共享数据。</p>
</li>
<li><p>主从式结构</p>
<ul>
<li>一个主机带多个终端的多用户结构</li>
<li>数据库系统，包括应用程序、DBMS、数据，都集中存放在主机上，所有处理任务都由主机来完成。各个用户通过主机的终端并发地存取数据库，共享数据资源。</li>
<li>优点<br>易于管理、控制与维护。</li>
<li>缺点<br>当终端用户数目增加到一定程度后，主机的任务会过分繁重，成为瓶颈，从而使系统性能下降。<br>系统的可靠性依赖主机,当主机出现故障时，整个系统都不能使用。</li>
</ul>
</li>
<li><p>分布式结构</p>
<ul>
<li>数据库中的数据在<strong>逻辑上是一个整体，但物理地分布</strong>在计算机网络的不同结点上。</li>
<li>网络中的每个结点都可以独立处理本地数据库中的数据，执行局部应用</li>
<li>同时也可以同时存取和处理多个异地数据库中的数据，执行全局应用</li>
<li>优点<br>适应了地理上分散的公司、团体和组织对于数据库应用的需求。</li>
<li>缺点<br>数据的分布存放给数据的处理、管理与维护带来困难。<br>当用户需要经常访问远程数据时，系统效率会明显地受到网络传输的制约。</li>
</ul>
</li>
<li><p>客户／服务器</p>
<ul>
<li>把DBMS功能和应用分开<br>网络中某个（些）结点上的计算机专门用于执行DBMS功能，称为<strong>数据库服务器</strong>，简称服务器，其他结点上的计算机安装DBMS的外围应用开发工具，用户的应用系统，称为<strong>客户机</strong></li>
<li>集中的服务器结构<br>一台数据库服务器，多台客户机</li>
<li>分布的服务器结构<br>在网络中有多台数据库服务器<br>分布的服务器结构是客户／服务器与分布式数据库的结合</li>
</ul>
</li>
<li><p>浏览器／应用服务器／数据库服务器多层结构</p>
<ul>
<li><p>客户端：<br>浏览器软件、用户界面</p>
<p> 浏览器的界面统一，广大用户容易掌握</p>
<p>大大减少了培训时间与费用。</p>
</li>
<li><p>服务器端分为两部分：<br>Web服务器、应用服务器<br>数据库服务器等</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>从数据库管理系统角度，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构 </p>
</li>
</ul>
<h3 id="4-2-数据库系统的三级模式结构"><a href="#4-2-数据库系统的三级模式结构" class="headerlink" title="4.2 数据库系统的三级模式结构"></a>4.2 数据库系统的三级模式结构</h3><ul>
<li>结构图</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png"></p>
<ul>
<li>模式<ol>
<li>模式（逻辑模式）<br><strong>数据库中全体数据的逻辑结构和特征的描述</strong><br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式</li>
<li>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关</li>
<li>模式的定义<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</li>
</ol>
</li>
<li>外模式（子模式、用户模式）<ol>
<li><strong>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</strong>，数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>外模式的地位：介于模式与应用之间<ul>
<li>模式与外模式的关系：一对多<br>外模式通常是模式的子集。<br>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求。<br>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。</li>
<li>外模式与应用的关系：一对多<br>同一外模式也可以为某一用户的多个应用系统所使用<br>但一个应用程序只能使用一个外模式</li>
</ul>
</li>
<li>外模式的用途<ul>
<li>保证数据库安全性的一个有力措施</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
</li>
</ol>
</li>
<li>内模式（存储模式）<ol>
<li><strong>是数据物理结构和存储方式的描述</strong></li>
<li><strong>是数据在数据库内部的表示方式</strong></li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B.png"></p>
<h3 id="4-3-数据库二级映像功能与数据独立性"><a href="#4-3-数据库二级映像功能与数据独立性" class="headerlink" title="4.3 数据库二级映像功能与数据独立性"></a>4.3 数据库二级映像功能与数据独立性</h3><ul>
<li><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p>
<ol>
<li><p>外模式／模式映像</p>
<ul>
<li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li>
<li>当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称<strong>数据的逻辑独立性</strong>。</li>
</ul>
</li>
<li><p>模式／内模式映像 </p>
<ul>
<li><p>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的</p>
</li>
<li><p>数据库中模式／内模式映象是唯一的，该映象定义通常包含在模式描述中</p>
</li>
<li><p>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变</p>
</li>
<li><p>应用程序不受影响。保证了数据与程序的物理独立性，简称<strong>数据的物理独立性</strong>。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" data-id="cknhe7bxb006tows6c6igeu0k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-deque" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/deque/" class="article-date">
  <time datetime="2020-03-05T12:53:48.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/deque/">deque</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="deque-容器"><a href="#deque-容器" class="headerlink" title="deque 容器"></a>deque 容器</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li>功能：双端数组，可以对头端进行插入删除操作,deque的迭代器支持随机访问</li>
<li>和vector的区别<ol>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度比vector快</li>
<li>vector访问元素时的速度没有deque快</li>
</ol>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/deque.PNG"></p>
<ul>
<li><p>内部工作原理</p>
<ol>
<li>deque有一个中控器，维护每段缓冲区的内容，缓冲区中存放真实数据</li>
<li>中控器维护的是每个缓冲区的地址，是的使用deque时像一片连续的内存空间</li>
<li>这种结构决定了比vector插入数据时要快，然而访问数据比vector慢</li>
</ol>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/deque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.PNG"></p>
</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><ul>
<li>函数原型<ol>
<li><code>deque&lt; T &gt; deq;</code>   //默认构造函数</li>
<li><code>deque(beg,end);</code>  //构造函数将[begin,end)区间的元素拷贝给本身</li>
<li><code>deque(n,elem);</code>  //构造函数将n个elem拷贝给本身</li>
<li><code>deque(const deque &amp;deq);</code>//拷贝构造函数</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; deq)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = deq.begin(); it != deq.end(); it++) &#123;</span><br><span class="line">		<span class="comment">//*it = 100;//报错，限定为只读状态</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		deq.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	printDeque(deq);</span><br><span class="line">	<span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(deq.begin(),deq.end())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3(d1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-赋值操作"><a href="#3-赋值操作" class="headerlink" title="3.赋值操作"></a>3.赋值操作</h3><ul>
<li>函数原型<ol>
<li><code>deque&amp; operator = (const deque &amp;deq);  </code></li>
<li><code>assign(beg,end);</code>// 将[begin,end)区间的元素拷贝给本身</li>
<li><code>assign(n,elem);</code>//将n个elem拷贝给本身</li>
</ol>
</li>
</ul>
<h3 id="4-大小操作"><a href="#4-大小操作" class="headerlink" title="4. 大小操作"></a>4. 大小操作</h3><ul>
<li>函数原型<ol>
<li><code>deque.empty();</code> //判断容器是否为空</li>
<li><code>deque.size();</code>//返回容器中元素的个数</li>
<li><code>deque.resize(num);</code>//重新指定容器的长度为num,若瑢变长，则以默认值填充新位置，如果变短，则末尾超出的容器长度的元素将会被删除</li>
<li><code>deque.resize(n,elem);</code>//多出的值用elem填充</li>
</ol>
</li>
</ul>
<h3 id="5-插入删除"><a href="#5-插入删除" class="headerlink" title="5. 插入删除"></a>5. 插入删除</h3><ul>
<li><p>函数原型</p>
<p>两端插入操作</p>
<ol>
<li><code>push_back();</code>//在容器尾部插入一个数据</li>
<li><code>push_front();</code> //在容器头部插入一个数据</li>
<li><code>pop_back();</code>//删除容器最后一个数据</li>
<li><code>pop_front();</code>//删除容器第一个数据</li>
</ol>
<p>指定位置操作</p>
<ol>
<li><code>insert(pos,elem);</code>//在pos位置插入一个elem,返回新数据的位置</li>
<li><code>insert(pos,n,elem);</code>//在pos位置插入n个elem元素，无返回值</li>
<li><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值</li>
<li><code>clear();</code></li>
<li><code>erase(beg,end);</code>//删除[beg,end)区间的数据，无返回值</li>
<li><code>erase(pos);</code>//删除pos位置的元素，返回下一个数据的位置</li>
</ol>
</li>
</ul>
<h3 id="6-数据存取"><a href="#6-数据存取" class="headerlink" title="6. 数据存取"></a>6. 数据存取</h3><ul>
<li>函数原型<ol>
<li><code>at(int idx);</code></li>
<li><code>operator[];</code></li>
<li><code>front();</code></li>
<li><code>back();</code></li>
</ol>
</li>
</ul>
<h3 id="7-排序"><a href="#7-排序" class="headerlink" title="7.排序"></a>7.排序</h3><ul>
<li><p>函数原型</p>
<p><code>sort(iterator beg,iterator end);</code>//默认升序</p>
<p>对于支持随机访问的迭代器的访问，都可以利用sort直接排序</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/05/deque/" data-id="cknhe7bvs003mows6gecrhci9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-优先级队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/03/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2020-03-03T07:50:56.000Z" itemprop="datePublished">2020-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/03/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">优先级队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="STL优先级队列"><a href="#STL优先级队列" class="headerlink" title="STL优先级队列"></a>STL优先级队列</h2><ul>
<li><p>priority_queue:自适应容器（容器适配器），不能使用list</p>
</li>
<li><p>最大值优先级队列：最大的在队列的最前面</p>
</li>
<li><p>最小值优先级队列：最小的在队列最前面</p>
</li>
<li><p>包含的头文件 queue</p>
</li>
<li><p>函数接口</p>
<p>priority_queue&lt;int,deque&lt; int &gt; &gt; pq; //默认最大值优先级队列</p>
<p>priority_queue&lt;int,vector&lt; int &gt; &gt; pq;</p>
<p>priority_queue&lt; int, deque&lt; int &gt;,<strong>greater</strong>&lt; int &gt;&gt; pq;//最小值优先级队列</p>
<p>pq.empty();</p>
<p>pq.size();</p>
<p>pq.top();</p>
<p>pq.pop();</p>
<p>pq.push(item);</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/03/03/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" data-id="cknhe7bwj0052ows60ikrdbs1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vector容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/29/vector%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-02-29T04:29:13.000Z" itemprop="datePublished">2020-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/29/vector%E5%AE%B9%E5%99%A8/">vector容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vector-容器"><a href="#Vector-容器" class="headerlink" title="Vector 容器"></a>Vector 容器</h2><h3 id="1-vector基本概念"><a href="#1-vector基本概念" class="headerlink" title="1 vector基本概念"></a>1 vector基本概念</h3><ul>
<li><p>功能</p>
<p>vector数据结构和数组十分相似，也称为单端数组</p>
</li>
<li><p>vector和普通数组的区别</p>
<p>不同之处在于数组是静态空间，而vector可以动态扩展</p>
</li>
<li><p>动态扩展</p>
<p><strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</strong></p>
</li>
</ul>
<p><img src="https://reborn-photo-url.oss-cn-beijing.aliyuncs.com/oss:/hxx_photo/vector.PNG"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h3 id="2-vector构造函数"><a href="#2-vector构造函数" class="headerlink" title="2 vector构造函数"></a>2 vector构造函数</h3><ul>
<li><p>功能描述</p>
<p>创造vector容器</p>
</li>
<li><p>函数原型</p>
<ol>
<li><code>vector &lt;T&gt; v</code>  //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(),v.end());</code>   将v[ begin(), end() ) 区间中的元素拷贝给本身</li>
<li><code>vector(n,elem);</code>    //构造函数将n个elem拷贝给本</li>
<li><code>vector(const vector &amp;vec);</code>   //拷贝构造函数</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	printVector(v1);</span><br><span class="line">	<span class="comment">//通过区间方式构造</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	printVector(v2);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">	printVector(v3);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4(v3);</span><br><span class="line">	printVector(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-vector赋值操作"><a href="#3-vector赋值操作" class="headerlink" title="3 vector赋值操作"></a>3 vector赋值操作</h3><ul>
<li>函数原型<ol>
<li><code>vector&amp; operator=(const vector &amp;vec)</code>  </li>
<li><code>assign(beg,end);</code>  //给[beg, end）区间中的数据拷贝复制给本身</li>
<li><code>assign(n,elem)</code>  //将n个elem拷贝赋值给本身</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  v1.push_back(i);  &#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	printVector(v2);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">	v3.assign(v1.begin(), v1.end());</span><br><span class="line">	printVector(v3);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">	v4.assign(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">	printVector(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-vector容量和大小"><a href="#4-vector容量和大小" class="headerlink" title="4 vector容量和大小"></a>4 vector容量和大小</h3><ul>
<li>函数原型<ol>
<li><code>empty();</code>  //判断容器是否为空</li>
<li><code>capacity();</code>  //容器的容量,<strong>容量大于等于长度</strong></li>
<li><code>size();</code>  //返回容器中元素的个数</li>
<li><code>resize(int num);</code> //重新指定容器的长度为num,若容器边长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li>
<li><code>resize(int num,elem)</code>  //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。若容器变短，则末尾超出容器长度的元素被删除。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void test03() &#123;</span><br><span class="line">	vector&lt;int&gt;v1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 5; i++) &#123; v1.push_back(i); &#125;</span><br><span class="line">	if (v1.empty())  cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;v1的容量为&quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;v1的大小为&quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;重回新指定大小</span><br><span class="line">	v1.resize(7);</span><br><span class="line">	printVector(v1);&#x2F;&#x2F;0 1 2 3 4 0 0</span><br><span class="line">	v1.resize(10,8);</span><br><span class="line">	printVector(v1);&#x2F;&#x2F;0 1 2 3 4 0 0 8 8 8</span><br><span class="line">	v1.resize(5);</span><br><span class="line">	printVector(v1);&#x2F;&#x2F;0 1 2 3 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-vector插入和删除"><a href="#5-vector插入和删除" class="headerlink" title="5 vector插入和删除"></a>5 vector插入和删除</h3><ul>
<li>函数原型<ol>
<li><code>push_back(elem);</code> //尾部插入元素</li>
<li><code>pop_back();</code>  //删除最后一个元素</li>
<li><code>insert(const_iterator pos,ele);</code>  //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos,int count,ele)；</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>//删除迭代器指向的元素</li>
<li><code>erase(const_iterator start,const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear()</code>；//删除容器中所有的元素</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; v1.push_back(i); &#125;</span><br><span class="line">	v1.pop_back();</span><br><span class="line">	printVector(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.insert(v1.begin(), <span class="number">100</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line">	v1.insert(v1.begin(),<span class="number">2</span>, <span class="number">50</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.erase(v1.end()<span class="number">-1</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line"></span><br><span class="line">	v1.erase(v1.begin(),v1.end()<span class="number">-2</span>);</span><br><span class="line">	printVector(v1);</span><br><span class="line">	v1.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-vector数据存取"><a href="#6-vector数据存取" class="headerlink" title="6 vector数据存取"></a>6 vector数据存取</h3><ul>
<li>函数原型<ol>
<li><code>at(int idx);</code>  //返回索引 idx 所值的数据</li>
<li><code>operator[];</code>  //返回索引 idx 所指的数据</li>
<li><code>front();</code>  //返回容器中第一个数据</li>
<li><code>back();</code>  // 返回容器中最后一个数据元素</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; v1.push_back(i); &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素&quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素&quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-vector互换容器"><a href="#7-vector互换容器" class="headerlink" title="7 vector互换容器"></a>7 vector互换容器</h3><ul>
<li><p>函数原型</p>
<p><code>swap(vec);</code>  </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巧用swap可以收缩内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.push_back(i);</span><br><span class="line">		v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量为&quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小为&quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	v1.resize(<span class="number">3</span>);<span class="comment">//容量没有变</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量为&quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小为&quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;(v1).swap(v1);</span><br><span class="line">	<span class="comment">//vector &lt;int&gt;(v1)</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量为&quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小为&quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1的容量为<span class="number">138255</span></span><br><span class="line">v1的大小为<span class="number">100000</span></span><br><span class="line">v1的容量为<span class="number">138255</span></span><br><span class="line">v1的大小为<span class="number">3</span></span><br><span class="line">v1的容量为<span class="number">3</span></span><br><span class="line">v1的大小为<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="8-vector预留空间"><a href="#8-vector预留空间" class="headerlink" title="8 vector预留空间"></a>8 vector预留空间</h3><ul>
<li><p>功能描述</p>
<p>减少vector在动态扩展容量时的扩展次数</p>
</li>
<li><p>函数原型</p>
<p><code>reserve(int len);</code> //容器预留len个元素长度，预留位置不初始化，元素不可访问</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//记录动态扩展次数</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="literal">NULL</span>;<span class="comment">//指向当前容器中的首元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//判断指针p所指的首元素地址是否发生变化，如果变化，则重新分配了内存，num加一并更新p</span></span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动态扩展次数：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态扩展次数：<span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>使用reserve后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.reserve(<span class="number">300</span>);<span class="comment">//预留空间</span></span><br></pre></td></tr></table></figure>

<p>运算结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态扩展次数：1</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hxx-98.github.io/2020/02/29/vector%E5%AE%B9%E5%99%A8/" data-id="cknhe7bwe004qows6b5qj4qwq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">Java设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSM/" rel="tag">SSM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaweb/" rel="tag">javaweb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" rel="tag">《数据库系统概论》</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Java设计模式</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/SSM/" style="font-size: 15px;">SSM</a> <a href="/tags/c/" style="font-size: 16.67px;">c++</a> <a href="/tags/javaweb/" style="font-size: 18.33px;">javaweb</a> <a href="/tags/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B/" style="font-size: 13.33px;">《数据库系统概论》</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/13/MyBatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">MyBatis多表查询</a>
          </li>
        
          <li>
            <a href="/2021/04/11/MyBatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A8%E6%80%81SQL/">MyBatis映射文件的动态SQL</a>
          </li>
        
          <li>
            <a href="/2021/04/09/MyBatis%E4%BA%8B%E5%8A%A1/">MyBatis事务</a>
          </li>
        
          <li>
            <a href="/2021/04/09/MyBatis%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">MyBatis数据库连接池</a>
          </li>
        
          <li>
            <a href="/2021/04/08/SqlMapConfig-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">SqlMapConfig.xml配置文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 hxx-98<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>